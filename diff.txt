diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9875d406..80958e34 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -377,6 +377,8 @@ endif()
 
 if (Enable_GUI)
 find_package(OpenGL)
+find_package(glad CONFIG REQUIRED)
+find_package(glm CONFIG REQUIRED)
 set(wxWidgets_USE_UNICODE ON)
 find_package(wxWidgets COMPONENTS net gl html aui adv core base)
 endif()
@@ -451,10 +453,15 @@ IF(wxWidgets_FOUND AND OPENGL_FOUND AND Enable_GUI)
     ${GUI_LIBDIR}/Widgets/ThemedMenuPopup.cpp
     ${GUI_LIBDIR}/Widgets/ThemedMenu.cpp
     ${GUI_LIBDIR}/Dialogs/WidgetGallery.cpp
+    ${GUI_LIBDIR}/GL/GLManager.cpp
+    ${GUI_LIBDIR}/GL/Shader.cpp
+    ${GUI_LIBDIR}/GL/Camera.cpp
+    ${GUI_LIBDIR}/GL/Buffer.cpp
     )
     target_compile_features(slic3r_gui PUBLIC cxx_std_17)
     target_include_directories(slic3r_gui PUBLIC ${SLIC3R_GUI_INCLUDES} ${SLIC3R_INCLUDES} )
     #only build GUI lib if building with wx
+    target_link_libraries (slic3r_gui ${wxWidgets_LIBRARIES} ${OPENGL_LIBRARIES} glad::glad glm::glm)
     target_link_libraries (slic3r slic3r_gui ${wxWidgets_LIBRARIES} ${OPENGL_LIBRARIES})
     add_compile_options(-DUSE_WX)
 
diff --git a/src/GUI/Dialogs/AboutDialog.cpp b/src/GUI/Dialogs/AboutDialog.cpp
index 76867c54..cb1764f0 100644
--- a/src/GUI/Dialogs/AboutDialog.cpp
+++ b/src/GUI/Dialogs/AboutDialog.cpp
@@ -108,7 +108,7 @@ AboutDialog::AboutDialog(wxWindow* parent)
 
     html->Bind(wxEVT_HTML_LINK_CLICKED, [](wxHtmlLinkEvent& e){ link_clicked(e); });
 
-    vsizer->Add(html, 1, wxEXPAND | wxALIGN_LEFT | wxRIGHT | wxBOTTOM, 20);
+    vsizer->Add(html, 1, wxEXPAND | wxRIGHT | wxBOTTOM, 20);
 
     // buttons
     auto buttons = this->CreateStdDialogButtonSizer(wxOK);
diff --git a/src/GUI/Dialogs/PresetEditor.cpp b/src/GUI/Dialogs/PresetEditor.cpp
index d0ef5728..0261c6e2 100644
--- a/src/GUI/Dialogs/PresetEditor.cpp
+++ b/src/GUI/Dialogs/PresetEditor.cpp
@@ -179,6 +179,24 @@ PresetPage* PresetEditor::add_options_page(const wxString& _title, const wxStrin
         }
     };
     
+    page->on_quick_setting_change = [this](const std::string& key, bool active) {
+        Slic3r::Log::info(this->LogChannel(), "Quick Setting Toggle: " + key);
+        
+        // Use global settings to persist
+        ui_settings->toggle_quick_setting(key);
+        bool now_active = ui_settings->is_quick_setting(key);
+
+        // Propagate up (e.g. to Plater to refresh the quick settings panel)
+        if (this->on_quick_setting_change) {
+            this->on_quick_setting_change(key, now_active);
+        }
+        
+        // Visual Feedback: Toggle the icon immediately for all pages
+        for (auto* p : _pages) {
+            p->set_quick_setting_status(key, now_active);
+        }
+    };
+
     return page;
 }
 
diff --git a/src/GUI/Dialogs/PresetEditor.hpp b/src/GUI/Dialogs/PresetEditor.hpp
index 4a9cf7ba..fa705abf 100644
--- a/src/GUI/Dialogs/PresetEditor.hpp
+++ b/src/GUI/Dialogs/PresetEditor.hpp
@@ -61,6 +61,7 @@ public:
     void save_preset();
     std::function<void (wxString, preset_t)> on_save_preset {nullptr};
     std::function<void (std::string)> on_value_change {nullptr};
+    std::function<void (std::string, bool)> on_quick_setting_change {nullptr};
 
     config_ptr config;
     void reload_config();
@@ -287,6 +288,7 @@ protected:
 class PresetPage : public wxScrolledWindow {
 public:
     std::function<void(const std::string&, boost::any)> on_change;
+    std::function<void(const std::string&, bool)> on_quick_setting_change;
 
     PresetPage(wxWindow* parent, wxString _title, int _iconID = 0) : 
         wxScrolledWindow(parent, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL),
@@ -304,6 +306,7 @@ public:
         auto* og = new OptionsGroup(this);
         og->set_sizer(sbs);
         og->on_change = this->on_change;
+        og->on_quick_setting_change = this->on_quick_setting_change;
         _optgroups.push_back(std::unique_ptr<OptionsGroup>(og));
         return og;
     }
@@ -322,6 +325,12 @@ public:
         return nullptr;
     }
 
+    void set_quick_setting_status(const std::string& key, bool active) {
+        for (auto& og : _optgroups) {
+            og->set_quick_setting_status(key, active);
+        }
+    }
+
 protected:
     wxSizer* vsizer {nullptr};
     wxString title {""};
diff --git a/src/GUI/MainFrame.hpp b/src/GUI/MainFrame.hpp
index d46f130d..509a7cab 100644
--- a/src/GUI/MainFrame.hpp
+++ b/src/GUI/MainFrame.hpp
@@ -1,4 +1,3 @@
-
 #ifndef MAINFRAME_HPP
 #define MAINFRAME_HPP
 #include <wx/wxprec.h>
diff --git a/src/GUI/OptionsGroup.cpp b/src/GUI/OptionsGroup.cpp
index 2108a190..49a92c6f 100644
--- a/src/GUI/OptionsGroup.cpp
+++ b/src/GUI/OptionsGroup.cpp
@@ -1,6 +1,7 @@
 #include "OptionsGroup.hpp"
 #include "OptionsGroup/Field.hpp"
 #include "Theme/ThemeManager.hpp"
+#include "misc_ui.hpp" /* For get_bmp_bundle */
 #include <wx/sizer.h>
 #include <wx/stattext.h>
 #include <wx/statbox.h>
@@ -29,24 +30,77 @@ void OptionsGroup::append_single_option_line(const t_config_option_key& opt_key)
 
     auto* line_sizer = new wxBoxSizer(wxHORIZONTAL);
     
+    // Quick Toggle Button
+    if (!this->star_filled.IsOk()) {
+        this->star_filled = get_bmp_bundle("star_filled.svg", 14);
+        this->star_empty = get_bmp_bundle("star_empty.svg", 14);
+    }
+
+    auto* btn_quick = new ThemedButton(parent, wxID_ANY, "", wxDefaultPosition, wxSize(20, 20));
+    btn_quick->SetBitmap(ui_settings->is_quick_setting(opt_key) ? this->star_filled : this->star_empty);
+    btn_quick->Bind(wxEVT_BUTTON, [this, opt_key, btn_quick](wxCommandEvent&) {
+        if (this->on_quick_setting_change) {
+             this->on_quick_setting_change(opt_key, true); 
+        }
+    });
+    line_sizer->Add(btn_quick, 0, wxALIGN_CENTER_VERTICAL | wxRIGHT, 2);
+    _quick_toggles[opt_key] = btn_quick;
+
+
     std::string label_text = opt_key;
-    if (print_config_def.has(opt_key)) {
-        label_text = print_config_def.get(opt_key).label;
+    std::string unit_text = "";
+
+    ConfigOptionDef def;
+    if (_options.count(opt_key)) def = _options[opt_key]->desc;
+    else if (print_config_def.has(opt_key)) def = print_config_def.get(opt_key);
+
+    if (!def.label.empty()) label_text = def.label;
+    if (def.full_label.empty()) def.full_label = label_text;
+
+    // Unit extraction
+    if (!def.sidetext.empty()) {
+        unit_text = def.sidetext;
+    } else {
+        // Parse from label if (unit) exists
+        size_t open_paren = label_text.find_last_of('(');
+        size_t close_paren = label_text.find_last_of(')');
+        if (open_paren != std::string::npos && close_paren != std::string::npos && close_paren > open_paren) {
+             unit_text = label_text.substr(open_paren + 1, close_paren - open_paren - 1);
+             // remove it from label
+             label_text = label_text.substr(0, open_paren);
+             // trim
+             while (!label_text.empty() && isspace(label_text.back())) label_text.pop_back();
+        }
     }
     
     auto* label = new wxStaticText(parent, wxID_ANY, wxString::FromUTF8(label_text + ":"));
     if (ThemeManager::IsDark()) label->SetForegroundColour(*wxWHITE);
     else label->SetForegroundColour(*wxBLACK);
     line_sizer->Add(label, 0, wxALIGN_CENTER_VERTICAL | wxRIGHT, 5);
+    _labels[opt_key] = label;
+
     if (this->get_option(opt_key).desc.type == coBool) {
         // Don't expand checkboxes, keeps the background highlight tight to the box
         line_sizer->Add(field->get_window(), 0, wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL);
     } else {
-        line_sizer->Add(field->get_window(), 1, wxEXPAND);
+        // Standardize width for text/inputs if single line
+        field->get_window()->SetMinSize(wxSize(120, -1)); // Enforce sensible width
+        line_sizer->Add(field->get_window(), 0, wxEXPAND);
+    }
+
+    if (!unit_text.empty()) {
+        auto* unit_lbl = new wxStaticText(parent, wxID_ANY, wxString::FromUTF8(unit_text));
+        if (ThemeManager::IsDark()) unit_lbl->SetForegroundColour(wxColour(150, 150, 150));
+        else unit_lbl->SetForegroundColour(wxColour(100, 100, 100));
+        line_sizer->Add(unit_lbl, 0, wxALIGN_CENTER_VERTICAL | wxLEFT, 5);
+        _units[opt_key] = unit_lbl;
     }
     
+    // Add spacer to push everything to left? Or use EXPAND?
+    line_sizer->AddStretchSpacer(1);
+
     if (this->sizer)
-        this->sizer->Add(line_sizer, 0, wxEXPAND | wxALL, 5);
+        this->sizer->Add(line_sizer, 0, wxEXPAND | wxALL, 2);
 }
 
 void OptionsGroup::append_line(const Line& line) {
@@ -119,7 +173,36 @@ void OptionsGroup::update_options(const ConfigBase* config, const std::vector<st
 
             // Update Dirty Status
             bool is_dirty = std::find(dirty_keys.begin(), dirty_keys.end(), key) != dirty_keys.end();
-            field->set_dirty_status(is_dirty);
+            // field->set_dirty_status(is_dirty); // OLD BEHAVIOR DISABLED
+            
+            // New Label Behavior
+            if (_labels.count(key)) {
+                wxStaticText* lbl = _labels[key];
+                if (is_dirty) {
+                   lbl->SetForegroundColour(wxColour(255, 128, 0)); // Orange
+                } else {
+                   if (ThemeManager::IsDark()) lbl->SetForegroundColour(*wxWHITE);
+                   else lbl->SetForegroundColour(*wxBLACK);
+                }
+                lbl->Refresh();
+            }
+
+            // Sync Quick Toggle State
+            if (_quick_toggles.count(key)) {
+                this->set_quick_setting_status(key, ui_settings->is_quick_setting(key));
+            }
+        }
+    }
+}
+
+void OptionsGroup::set_quick_setting_status(const std::string& opt_key, bool active) {
+    if (_quick_toggles.count(opt_key)) {
+        if (auto* btn = dynamic_cast<ThemedButton*>(_quick_toggles[opt_key])) {
+            if (!this->star_filled.IsOk()) {
+                 this->star_filled = get_bmp_bundle("star_filled.svg", 14);
+                 this->star_empty = get_bmp_bundle("star_empty.svg", 14);
+            }
+            btn->SetBitmap(active ? this->star_filled : this->star_empty);
         }
     }
 }
@@ -171,7 +254,7 @@ UI_Field* OptionsGroup::build_field(const t_config_option_key& opt_key) {
             break;
         }
         case coEnum: {
-            auto* f = new UI_TextCtrl(parent, def);
+            auto* f = new UI_Choice(parent, def);
              f->on_change = [this, opt_key](const std::string&, std::string val) { 
                if (this->on_change) this->on_change(opt_key, val);
             };
diff --git a/src/GUI/OptionsGroup.hpp b/src/GUI/OptionsGroup.hpp
index e2eedff7..27ef5b60 100644
--- a/src/GUI/OptionsGroup.hpp
+++ b/src/GUI/OptionsGroup.hpp
@@ -26,30 +26,12 @@ public:
         desc.default_value = _def.clone();
     }
 
-    Option(const Option& other) : opt_id(other.opt_id), desc(other.desc) {
-        if (other.desc.default_value)
-            desc.default_value = other.desc.default_value->clone();
-    }
-
-    Option(Option&& other) noexcept : opt_id(std::move(other.opt_id)), desc(std::move(other.desc)) {
-        other.desc.default_value = nullptr;
-    }
-
-    Option& operator=(Option other) {
-        swap(*this, other);
-        return *this;
-    }
-
-    ~Option() {
-        if (desc.default_value) delete desc.default_value;
-        desc.default_value = nullptr;
-    }
-
-    friend void swap(Option& first, Option& second) {
-        using std::swap;
-        swap(first.opt_id, second.opt_id);
-        swap(first.desc, second.desc);
-    }
+    // Rely on ConfigOptionDef's copy constructor and destructor
+    Option(const Option& other) = default;
+    Option(Option&& other) = default;
+    Option& operator=(const Option& other) = default;
+    Option& operator=(Option&& other) = default;
+    ~Option() = default;
 };
 
 class Line {
@@ -94,12 +76,27 @@ public:
     void update_options(const ConfigBase* config, const std::vector<std::string>& dirty_keys = {});
 
     std::function<void(const std::string&, boost::any)> on_change {nullptr};
+    
+    // Callback for Quick Setting Toggle (key, is_active)
+    std::function<void(const std::string&, bool)> on_quick_setting_change {nullptr};
+
+    void set_quick_setting_status(const std::string& opt_key, bool active);
 
 protected:
     wxWindow* parent;
     std::map<t_config_option_key, std::unique_ptr<Option>> _options;
     std::map<t_config_option_key, std::unique_ptr<UI_Field>> _fields;
+    
+    // UI Elements storage
+    std::map<t_config_option_key, wxStaticText*> _labels;
+    std::map<t_config_option_key, wxStaticText*> _units;
+    // We use a simple bitmap button or static bitmap for the star
+    std::map<t_config_option_key, wxWindow*> _quick_toggles; 
+    
     wxBoxSizer* sizer; // The sizer this group populates
+
+    wxBitmapBundle star_filled;
+    wxBitmapBundle star_empty;
 };
 
 class ConfigOptionsGroup : public OptionsGroup {
diff --git a/src/GUI/OptionsGroup/Field.hpp b/src/GUI/OptionsGroup/Field.hpp
index 2cb80b2d..789d2141 100644
--- a/src/GUI/OptionsGroup/Field.hpp
+++ b/src/GUI/OptionsGroup/Field.hpp
@@ -1,6 +1,5 @@
 #ifndef SLIC3R_FIELD_HPP
 #define SLIC3R_FIELD_HPP
-
 #include <functional>
 #include <string>
 #include <limits>
@@ -73,6 +72,8 @@ protected:
     
 public:
     virtual void set_dirty_status(bool dirty) {
+        // Disabled: Dirty status is now handled by the label in OptionsGroup
+        /*
         if (!this->window) return;
         if (dirty) {
              this->window->SetForegroundColour(wxColour(255, 128, 0)); // Orange
@@ -80,6 +81,7 @@ public:
              this->window->SetForegroundColour(wxNullColour); // Reset to default
         }
         this->window->Refresh();
+        */
     }
 };
 
@@ -233,11 +235,14 @@ public:
     
     // Override to ensure we set color on the actual text control, not the wrapper
     void set_dirty_status(bool dirty) override {
+        // Disabled: Dirty status is updated on Label
+        /*
         if (_text) {
              if (dirty) _text->SetForegroundColour(wxColour(255, 128, 0));
              else _text->SetForegroundColour(ThemeManager::GetColors().text);
              _text->Refresh();
         }
+        */
     }
 
     wxTextCtrl* textctrl() { return _text; }
@@ -268,6 +273,8 @@ public:
     void set_value(boost::any value) override;
 
     void set_dirty_status(bool dirty) override {
+        // Disabled
+        /*
         if (this->_combo) {
              if (dirty) this->_combo->SetForegroundColour(wxColour(255, 128, 0));
              else this->_combo->SetForegroundColour(wxNullColour);
@@ -281,11 +288,12 @@ public:
             // base fallback
             UI_Field::set_dirty_status(dirty);
         }
+        */
     }
 
     std::function<void (const std::string&, std::string value)> on_change {nullptr};
 
-    wxChoice* choice() { return this->_choice; }
+    ThemedSelect* choice() { return this->_choice; }
     wxComboBox* combo() { return this->_combo; }
 protected:
     virtual std::string LogChannel() override { return "UI_Choice"s; }
@@ -297,7 +305,7 @@ protected:
     }
 private:
     wxComboBox* _combo {nullptr};
-    wxChoice* _choice {nullptr};
+    ThemedSelect* _choice {nullptr};
 };
 
 
@@ -318,6 +326,8 @@ public:
     void set_value(boost::any value) override;
 
     void set_dirty_status(bool dirty) override {
+        // Disabled
+        /*
         if (this->_choice) {
              if (dirty) this->_choice->SetForegroundColour(wxColour(255, 128, 0));
              else this->_choice->SetForegroundColour(wxNullColour);
@@ -325,6 +335,7 @@ public:
         } else {
              UI_Field::set_dirty_status(dirty);
         }
+        */
     }
 
     std::function<void (const std::string&, std::string value)> on_change {nullptr};
@@ -491,11 +502,14 @@ public:
 protected:
     virtual std::string LogChannel() override { return "UI_Slider"s; }
     void set_dirty_status(bool dirty) override {
+        // Disabled
+        /*
         if (this->_textctrl) {
              if (dirty) this->_textctrl->SetForegroundColour(wxColour(255, 128, 0));
              else this->_textctrl->SetForegroundColour(wxNullColour);
              this->_textctrl->Refresh();
         }
+        */
     }
 
 private:
diff --git a/src/GUI/OptionsGroup/UI_Choice.cpp b/src/GUI/OptionsGroup/UI_Choice.cpp
index b36abd17..4dbcd966 100644
--- a/src/GUI/OptionsGroup/UI_Choice.cpp
+++ b/src/GUI/OptionsGroup/UI_Choice.cpp
@@ -11,13 +11,14 @@ UI_Choice::UI_Choice(wxWindow* parent, Slic3r::ConfigOptionDef _opt, wxWindowID
     for (auto v : opt.enum_values) values.Add(wxString(v));
 
     if (opt.gui_type.size() > 0 && opt.gui_type.compare("select_open"s)) {
-        _choice = new wxChoice(parent, id, 
-                wxDefaultPosition, _default_size(), values, style);
-        _choice->Bind(wxEVT_CHOICE, [this](wxCommandEvent& e) { this->_on_change(""); e.Skip(); });
+        _choice = new ThemedSelect(parent, id, values, wxDefaultPosition, _default_size());
+        // ThemedSelect should trigger events, binding to the control should work if it mimics basic events
+        // Assuming it emits wxEVT_COMBOBOX or similar command events
+        _choice->Bind(wxEVT_COMBOBOX, [this](wxCommandEvent& e) { this->_on_change(""); e.Skip(); }); 
         window = _choice;
     } else {
         _combo = new wxComboBox(parent, id, 
-                (opt.default_value != nullptr ? opt.default_value->getString() : ""),
+                (opt.default_value != nullptr ? opt.default_value->serialize() : ""),
                 wxDefaultPosition, _default_size(), values, style);
         _combo->Bind(wxEVT_COMBOBOX, [this](wxCommandEvent& e) { this->_on_change(""); e.Skip(); });
         window = _combo;
diff --git a/src/GUI/OptionsGroup/UI_Color.cpp b/src/GUI/OptionsGroup/UI_Color.cpp
index 0e9d9546..8ffe1c30 100644
--- a/src/GUI/OptionsGroup/UI_Color.cpp
+++ b/src/GUI/OptionsGroup/UI_Color.cpp
@@ -6,7 +6,7 @@ namespace Slic3r { namespace GUI {
 UI_Color::UI_Color(wxWindow* parent, Slic3r::ConfigOptionDef _opt ) : UI_Window(parent, _opt) { 
     wxColour default_color(255,255,255,255);
     if (_opt.default_value != nullptr) {
-        default_color = _string_to_color(_opt.default_value->getString());
+        default_color = _string_to_color(_opt.default_value->serialize());
     }
     this->_picker = new wxColourPickerCtrl(parent, wxID_ANY, default_color, wxDefaultPosition, this->_default_size());
     this->window = dynamic_cast<wxWindow*>(this->_picker);
diff --git a/src/GUI/OptionsGroup/UI_NumChoice.cpp b/src/GUI/OptionsGroup/UI_NumChoice.cpp
index 726cdbb5..b473de70 100644
--- a/src/GUI/OptionsGroup/UI_NumChoice.cpp
+++ b/src/GUI/OptionsGroup/UI_NumChoice.cpp
@@ -91,11 +91,11 @@ UI_NumChoice::UI_NumChoice(wxWindow* parent, Slic3r::ConfigOptionDef _opt, wxWin
 
 
     _choice = new wxComboBox(parent, id, 
-            (opt.default_value != nullptr ? opt.default_value->getString() : ""),
+            (opt.default_value != nullptr ? opt.default_value->serialize() : ""),
             wxDefaultPosition, _default_size(), values, style);
     window = _choice;
 
-    this->set_value(opt.default_value != nullptr ? opt.default_value->getString() : "");
+    this->set_value(opt.default_value != nullptr ? opt.default_value->serialize() : "");
 
 
     // Event handler for data entry and changing the combobox
diff --git a/src/GUI/Plater.cpp b/src/GUI/Plater.cpp
index 0123b4c1..c8b3741b 100644
--- a/src/GUI/Plater.cpp
+++ b/src/GUI/Plater.cpp
@@ -29,6 +29,7 @@
 #include "Dialogs/ObjectCutDialog.hpp"
 #include "Dialogs/ObjectSettingsDialog.hpp"
 #include "Dialogs/PresetEditor.hpp"
+#include "OptionsGroup.hpp"
 
 
 namespace Slic3r { namespace GUI {
@@ -196,7 +197,15 @@ Plater::Plater(wxWindow* parent, const wxString& title) :
         wxPostEvent(this, new wxPlThreadEvent(-1, PROGRESS_BAR_EVENT, 
     });
     */
+    _presets->on_change = [this](preset_t) {
+        this->load_current_presets();
+        this->refresh_canvases();
+        if (this->quick_options_group) {
+             this->quick_options_group->update_options(&this->config->config());
+        }
+    };
     _presets->load();
+    this->load_current_presets();
 
     this->preview_notebook = new wxSimplebook(this, wxID_ANY);
 
@@ -317,19 +326,20 @@ Plater::Plater(wxWindow* parent, const wxString& title) :
     this->selection_changed();
 
 
-    // Quick Settings Placeholder
-    wxStaticBoxSizer* shortcut_sizer {nullptr};
+    // Quick Settings placeholder
     {
         auto* box {new wxStaticBox(this, wxID_ANY, _("Quick Settings"))};
-        shortcut_sizer = new wxStaticBoxSizer(box, wxVERTICAL);
-        shortcut_sizer->SetMinSize(wxSize(350, 60)); // Small height for now
+        this->shortcut_sizer = new wxStaticBoxSizer(box, wxVERTICAL);
+        this->shortcut_sizer->SetMinSize(wxSize(350, 60)); 
         
         this->quick_settings_label = new wxStaticText(box, wxID_ANY, _("Pinned settings will appear here..."), wxDefaultPosition, wxDefaultSize, wxALIGN_CENTER_HORIZONTAL);
         this->quick_settings_label->SetFont(ui_settings->small_font());
         if (ThemeManager::IsDark()) this->quick_settings_label->SetForegroundColour(*wxWHITE);
-        shortcut_sizer->Add(this->quick_settings_label, 1, wxEXPAND | wxTOP | wxBOTTOM, 15);
+        this->shortcut_sizer->Add(this->quick_settings_label, 1, wxEXPAND | wxTOP | wxBOTTOM, 15);
     }
 
+    this->update_quick_settings();
+
 
     // Toolbar
     this->build_toolbar();
@@ -341,7 +351,7 @@ Plater::Plater(wxWindow* parent, const wxString& title) :
     left_sizer->Add(this->_presets, 0, wxEXPAND | wxTOP, 10);
     this->_presets->Show();
 
-    left_sizer->Add(shortcut_sizer, 0, wxEXPAND | wxTOP, 5);
+    left_sizer->Add(this->shortcut_sizer, 0, wxEXPAND | wxTOP, 5);
 
 //    $right_sizer->Add($self->{settings_override_panel}, 1, wxEXPAND, 5);
     left_sizer->Add(object_info_sizer, 0, wxEXPAND, 0);
@@ -397,6 +407,8 @@ void Plater::update_ui_from_settings() {
         if (ThemeManager::IsDark()) this->quick_settings_label->SetForegroundColour(*wxWHITE);
         else this->quick_settings_label->SetForegroundColour(*wxBLACK);
     }
+    
+    this->update_quick_settings();
 
     this->Refresh();
 }
@@ -1557,6 +1569,12 @@ void Plater::show_preset_editor(preset_t group, unsigned int idx) {
     }
     
     if (editor) {
+        if (auto* pe = dynamic_cast<PresetEditor*>(editor)) {
+             pe->on_quick_setting_change = [this](const std::string& key, bool active) {
+                  this->update_quick_settings();
+             };
+        }
+
         wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
         // Add editor to dialog sizer
         sizer->Add(editor, 1, wxEXPAND);
@@ -1728,4 +1746,49 @@ void Plater::slice() {
     }).detach();
 }
 
+void Plater::update_quick_settings() {
+    if (!this->shortcut_sizer) return;
+    
+    // Clear sizer
+    this->shortcut_sizer->Clear(true);
+    this->quick_options_group = nullptr;
+    this->quick_settings_label = nullptr;
+
+    if (ui_settings->quick_settings.empty()) {
+        this->quick_settings_label = new wxStaticText(this->shortcut_sizer->GetStaticBox(), wxID_ANY, _("Pinned settings will appear here..."), wxDefaultPosition, wxDefaultSize, wxALIGN_CENTER_HORIZONTAL);
+        this->quick_settings_label->SetFont(ui_settings->small_font());
+        if (ThemeManager::IsDark()) this->quick_settings_label->SetForegroundColour(*wxWHITE);
+        else this->quick_settings_label->SetForegroundColour(*wxBLACK);
+        this->shortcut_sizer->Add(this->quick_settings_label, 1, wxEXPAND | wxTOP | wxBOTTOM, 15);
+    } else {
+        this->quick_options_group = new OptionsGroup(this->shortcut_sizer->GetStaticBox());
+        this->quick_options_group->set_sizer(this->shortcut_sizer);
+        
+        for (const auto& key : ui_settings->quick_settings) {
+            this->quick_options_group->append_single_option_line(key);
+        }
+        
+        this->quick_options_group->on_change = [this](const std::string& key, boost::any value) {
+             try {
+                if (value.type() == typeid(bool)) this->config->set(key, boost::any_cast<bool>(value));
+                else if (value.type() == typeid(int)) this->config->set(key, boost::any_cast<int>(value));
+                else if (value.type() == typeid(double)) this->config->set(key, boost::any_cast<double>(value));
+                else if (value.type() == typeid(std::string)) this->config->set(key, boost::any_cast<std::string>(value));
+                
+                // Propagate to print
+                this->print->apply_config(this->config->config());
+            } catch(...) {}
+        };
+
+        this->quick_options_group->on_quick_setting_change = [this](const std::string& key, bool) {
+            ui_settings->toggle_quick_setting(key);
+            this->update_quick_settings();
+        };
+
+        this->quick_options_group->update_options(&this->config->config());
+    }
+    
+    this->Layout();
+}
+
 }} // Namespace Slic3r::GUI
\ No newline at end of file
diff --git a/src/GUI/Plater.hpp b/src/GUI/Plater.hpp
index 321f499c..5ff85b42 100644
--- a/src/GUI/Plater.hpp
+++ b/src/GUI/Plater.hpp
@@ -36,6 +36,7 @@
 namespace Slic3r { namespace GUI {
 
 class PresetChooser; // forward dec
+class OptionsGroup;
 using UndoOperation = int;
 
 enum class UndoCmd {
@@ -127,6 +128,7 @@ public:
     void select_view(Direction dir);
 
     void update_ui_from_settings();
+    void update_quick_settings();
     
     /// Load configuration from currently selected presets into 'this->config' and 'this->print'
     void load_current_presets();
@@ -166,7 +168,7 @@ private:
 
     // PreviewDLP* previewDLP {nullptr}; //< DLP/SLA Preview canvas
 
-    wxStaticBoxSizer* object_info_size {nullptr};
+    wxStaticBoxSizer* shortcut_sizer {nullptr};
     wxStaticText* quick_settings_label {nullptr};
 
     /// Handles the actual load of the file from the dialog handoff.
@@ -284,6 +286,7 @@ private:
     info_fields object_info;
 
     PresetChooser* _presets;
+    OptionsGroup* quick_options_group {nullptr};
 
     void load_presets();
 
diff --git a/src/GUI/Plater/PresetChooser.cpp b/src/GUI/Plater/PresetChooser.cpp
index 81dee333..e2c47810 100644
--- a/src/GUI/Plater/PresetChooser.cpp
+++ b/src/GUI/Plater/PresetChooser.cpp
@@ -57,8 +57,8 @@ PresetChooser::PresetChooser(wxWindow* parent, std::weak_ptr<Print> print, Setti
         });
 
         this->_local_sizer->Add(text, 0, wxALIGN_RIGHT | wxALIGN_CENTER_VERTICAL | wxRIGHT, 4);
-        this->_local_sizer->Add(choice, 1, wxALIGN_CENTER_VERTICAL | wxEXPAND | wxBOTTOM, 0);
-        this->_local_sizer->Add(settings_btn, 0, wxALIGN_CENTER_VERTICAL | wxEXPAND | wxLEFT, 3);
+        this->_local_sizer->Add(choice, 1, wxEXPAND | wxBOTTOM, 0);
+        this->_local_sizer->Add(settings_btn, 0, wxEXPAND | wxLEFT, 3);
         
         // setup listener. 
         // On a combobox event, puts a call to _on_change_combobox() on the evt_idle stack.
@@ -186,6 +186,9 @@ void PresetChooser::_on_select_preset(preset_t preset) {
     if (preset == preset_t::Printer) {
         this->load(); // reload print/filament settings to honor compatible printers
     }
+    if (this->on_change) {
+        this->on_change(preset);
+    }
 }
 
 bool PresetChooser::prompt_unsaved_changes() {
@@ -271,9 +274,24 @@ void PresetChooser::UpdateTheme()
         text->SetForegroundColour(dark ? *wxWHITE : *wxBLACK);
     }
 
-    for (auto& group : preset_choosers) {
-        for (auto* choice : group) {
-            // choice->UpdateTheme(); // If ThemedSelect exposes it? It repaints nicely on usage.
+    for (auto group : { preset_t::Printer, preset_t::Material, preset_t::Print }) {
+        for (auto* choice : this->preset_choosers[get_preset(group)]) {
+            for (size_t i = 0; i < choice->GetCount(); ++i) {
+                wxBitmapBundle bitmap;
+                switch (group) {
+                    case preset_t::Print:
+                        bitmap = get_bmp_bundle("cog.svg");
+                        break;
+                    case preset_t::Material: 
+                        bitmap = get_bmp_bundle("spool.svg");
+                        break;
+                    case preset_t::Printer: 
+                        bitmap = get_bmp_bundle("printer_empty.svg");
+                        break;
+                    default: break;
+                }
+                choice->SetItemIcon((int)i, bitmap);
+            }
             choice->Refresh();
         }
     }
diff --git a/src/GUI/Plater/PresetChooser.hpp b/src/GUI/Plater/PresetChooser.hpp
index 3a1e139f..651b01ea 100644
--- a/src/GUI/Plater/PresetChooser.hpp
+++ b/src/GUI/Plater/PresetChooser.hpp
@@ -11,6 +11,7 @@
 
 #include <vector>
 #include <array>
+#include <functional>
 
 #include "Print.hpp"
 
@@ -27,6 +28,7 @@ using chooser_name_map = std::array<chooser_name_list, preset_types>;
 
 class PresetChooser : public wxPanel {
 public:
+    std::function<void(preset_t)> on_change {nullptr};
 
     /// Build a panel to contain a sizer for dropdowns for preset selection.
     PresetChooser(wxWindow* parent, std::weak_ptr<Print> print);
diff --git a/src/GUI/Preferences.cpp b/src/GUI/Preferences.cpp
index 34336a59..461dda36 100644
--- a/src/GUI/Preferences.cpp
+++ b/src/GUI/Preferences.cpp
@@ -2,6 +2,7 @@
 #include "GUI.hpp"
 #include "Settings.hpp"
 #include "Theme/ThemeManager.hpp"
+#include "Widgets/ThemedControls.hpp"
 #include "libslic3r/Config.hpp"
 #include "libslic3r/PrintConfig.hpp"
 #include <wx/statbox.h>
@@ -255,10 +256,13 @@ PreferencesDialog::PreferencesDialog(wxWindow* parent)
 
     sizer->Add(sb_sizer, 1, wxEXPAND | wxALL, 10);
 
-    auto buttons = this->CreateStdDialogButtonSizer(wxOK | wxCANCEL);
-    this->Bind(wxEVT_BUTTON, [this](wxCommandEvent&) { this->_accept(); }, wxID_OK);
+    auto* btn_sizer = new wxBoxSizer(wxHORIZONTAL);
+    btn_sizer->AddStretchSpacer();
+    auto* ok_btn = new ThemedButton(this, wxID_OK, _("OK"));
+    ok_btn->Bind(wxEVT_BUTTON, [this](wxCommandEvent&) { this->_accept(); });
+    btn_sizer->Add(ok_btn, 0, wxALL, 10);
     
-    sizer->Add(buttons, 0, wxEXPAND | wxALL, 10);
+    sizer->Add(btn_sizer, 0, wxEXPAND);
 
     this->SetSizer(sizer);
     sizer->SetSizeHints(this);
diff --git a/src/GUI/Preset.hpp b/src/GUI/Preset.hpp
index a1ab2341..f82b9b1c 100644
--- a/src/GUI/Preset.hpp
+++ b/src/GUI/Preset.hpp
@@ -1,6 +1,5 @@
 #ifndef PRESET_HPP
 #define PRESET_HPP
-
 // Libslic3r 
 #include "PrintConfig.hpp"
 #include "Config.hpp"
diff --git a/src/GUI/Scene3D.cpp b/src/GUI/Scene3D.cpp
index 45e907a1..c02bea55 100644
--- a/src/GUI/Scene3D.cpp
+++ b/src/GUI/Scene3D.cpp
@@ -1,142 +1,34 @@
 #include "Scene3D.hpp"
 #include "Theme/CanvasTheme.hpp"
-#include "Line.hpp"
-#include "ClipperUtils.hpp"
-#include "misc_ui.hpp"
 #include "Log.hpp"
-#ifdef __APPLE__
-#include <OpenGL/glu.h>
-#else
-#include <GL/glu.h>
-#endif
-namespace Slic3r { namespace GUI {
-
-#ifndef GL_MULTISAMPLE
-#define GL_MULTISAMPLE 0x809D
-#endif
-
-#ifdef _WIN32
-#include <windows.h>
-#endif
-
-// OpenGL Function Pointers
-typedef char GLchar;
-typedef ptrdiff_t GLsizeiptr;
-typedef ptrdiff_t GLintptr;
-
-#define GL_COMPILE_STATUS 0x8B81
-#define GL_LINK_STATUS 0x8B82
-#define GL_INFO_LOG_LENGTH 0x8B84
-#define GL_FRAGMENT_SHADER 0x8B30
-#define GL_VERTEX_SHADER 0x8B31
+#include "ExtrusionGeometry.hpp"
+#include "libslic3r/ClipperUtils.hpp"
 
-typedef void (APIENTRY *PFNGLUSEPROGRAMPROC) (GLuint program);
-typedef void (APIENTRY *PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
-typedef GLuint (APIENTRY *PFNGLCREATESHADERPROC) (GLenum type);
-typedef void (APIENTRY *PFNGLCOMPILESHADERPROC) (GLuint shader);
-typedef GLuint (APIENTRY *PFNGLCREATEPROGRAMPROC) (void);
-typedef void (APIENTRY *PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
-typedef void (APIENTRY *PFNGLLINKPROGRAMPROC) (GLuint program);
-typedef void (APIENTRY *PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
-typedef void (APIENTRY *PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
-typedef void (APIENTRY *PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
-typedef void (APIENTRY *PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
-typedef GLint (APIENTRY *PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
-typedef void (APIENTRY *PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
-typedef void (APIENTRY *PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
-typedef void (APIENTRY *PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
-typedef void (APIENTRY *PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
-typedef void (APIENTRY *PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
-typedef GLint (APIENTRY *PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
-typedef void (APIENTRY *PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
-
-static PFNGLUSEPROGRAMPROC glUseProgram = nullptr;
-static PFNGLSHADERSOURCEPROC glShaderSource = nullptr;
-static PFNGLCREATESHADERPROC glCreateShader = nullptr;
-static PFNGLCOMPILESHADERPROC glCompileShader = nullptr;
-static PFNGLCREATEPROGRAMPROC glCreateProgram = nullptr;
-static PFNGLATTACHSHADERPROC glAttachShader = nullptr;
-static PFNGLLINKPROGRAMPROC glLinkProgram = nullptr;
-static PFNGLGETSHADERIVPROC glGetShaderiv = nullptr;
-static PFNGLGETPROGRAMIVPROC glGetProgramiv = nullptr;
-static PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog = nullptr;
-static PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog = nullptr;
-static PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation = nullptr;
-static PFNGLUNIFORM1FPROC glUniform1f = nullptr;
-static PFNGLUNIFORM3FPROC glUniform3f = nullptr;
-static PFNGLENABLEVERTEXATTRIBARRAYPROC glEnableVertexAttribArray = nullptr;
-static PFNGLDISABLEVERTEXATTRIBARRAYPROC glDisableVertexAttribArray = nullptr;
-static PFNGLVERTEXATTRIBPOINTERPROC glVertexAttribPointer = nullptr;
-static PFNGLGETATTRIBLOCATIONPROC glGetAttribLocation = nullptr;
-static PFNGLVERTEXATTRIB1FPROC glVertexAttrib1f = nullptr;
-
-static bool extensions_loaded = false;
-
-static void load_gl_extensions() {
-    if (extensions_loaded) return;
-    
-    #ifdef _WIN32
-    glUseProgram = (PFNGLUSEPROGRAMPROC)wglGetProcAddress("glUseProgram");
-    glShaderSource = (PFNGLSHADERSOURCEPROC)wglGetProcAddress("glShaderSource");
-    glCreateShader = (PFNGLCREATESHADERPROC)wglGetProcAddress("glCreateShader");
-    glCompileShader = (PFNGLCOMPILESHADERPROC)wglGetProcAddress("glCompileShader");
-    glCreateProgram = (PFNGLCREATEPROGRAMPROC)wglGetProcAddress("glCreateProgram");
-    glAttachShader = (PFNGLATTACHSHADERPROC)wglGetProcAddress("glAttachShader");
-    glLinkProgram = (PFNGLLINKPROGRAMPROC)wglGetProcAddress("glLinkProgram");
-    glGetShaderiv = (PFNGLGETSHADERIVPROC)wglGetProcAddress("glGetShaderiv");
-    glGetProgramiv = (PFNGLGETPROGRAMIVPROC)wglGetProcAddress("glGetProgramiv");
-    glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)wglGetProcAddress("glGetShaderInfoLog");
-    glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)wglGetProcAddress("glGetProgramInfoLog");
-    glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)wglGetProcAddress("glGetUniformLocation");
-    glUniform1f = (PFNGLUNIFORM1FPROC)wglGetProcAddress("glUniform1f");
-    glUniform3f = (PFNGLUNIFORM3FPROC)wglGetProcAddress("glUniform3f");
-    glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)wglGetProcAddress("glEnableVertexAttribArray");
-    glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)wglGetProcAddress("glDisableVertexAttribArray");
-    glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)wglGetProcAddress("glVertexAttribPointer");
-    glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)wglGetProcAddress("glGetAttribLocation");
-    glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)wglGetProcAddress("glVertexAttrib1f");
-    
-    if (!glUseProgram) {
-        Slic3r::Log::error("GUI", "Failed to load OpenGL extensions.");
-    } else {
-        Slic3r::Log::info("GUI", "OpenGL extensions loaded successfully.");
-        extensions_loaded = true;
-    }
-    #endif
-}
+// GLM
+#include <glm/glm.hpp>
+#include <glm/gtc/type_ptr.hpp>
 
-// Define attributes as a static array to avoid C4576 (non-standard C++ extension)
-static const int gl_attrs[] = {
-    WX_GL_RGBA, 
-    WX_GL_DOUBLEBUFFER, 
-    WX_GL_DEPTH_SIZE, 16,
-    WX_GL_SAMPLE_BUFFERS, 1,
-    WX_GL_SAMPLES, 4,
-    0
-};
+namespace Slic3r { namespace GUI {
 
 Scene3D::Scene3D(wxWindow* parent, const wxSize& size) :
-    wxGLCanvas(parent, wxID_ANY, gl_attrs, wxDefaultPosition, size)
-{ 
-
-
+    wxGLCanvas(parent, wxID_ANY, NULL, wxDefaultPosition, size)
+{
+    // Request OpenGL 4.6 Core Profile
     wxGLContextAttrs ctxAttrs;
-    ctxAttrs.PlatformDefaults().OGLVersion(4, 6).CompatibilityProfile().EndList();
-    this->glContext = new wxGLContext(this, nullptr, &ctxAttrs);
-    this->Bind(wxEVT_PAINT, [this](wxPaintEvent &e) { this->repaint(e); });
-    this->Bind(wxEVT_SIZE, [this](wxSizeEvent &e ){
-        dirty = true;
-        Refresh();
-    });
+    ctxAttrs.PlatformDefaults().OGLVersion(4, 6).CoreProfile().EndList();
     
+    m_context = new wxGLContext(this, nullptr, &ctxAttrs);
     
-    // Bind the varying mouse events
+    // Bind Events
+    this->Bind(wxEVT_PAINT, [this](wxPaintEvent &e) { this->repaint(e); });
+    this->Bind(wxEVT_SIZE, [this](wxSizeEvent &e ){ resize(); });
     this->Bind(wxEVT_MOTION, [this](wxMouseEvent &e) { this->mouse_move(e); });
     this->Bind(wxEVT_LEFT_UP, [this](wxMouseEvent &e) { this->mouse_up(e); });
     this->Bind(wxEVT_RIGHT_UP, [this](wxMouseEvent &e) { this->mouse_up(e); });
     this->Bind(wxEVT_MIDDLE_DCLICK, [this](wxMouseEvent &e) { this->mouse_dclick(e); });
     this->Bind(wxEVT_MOUSEWHEEL, [this](wxMouseEvent &e) { this->mouse_wheel(e); });
     
+    // Default Bed
     Points p;
     const coord_t w = scale_(200), z = 0;
     p.push_back(Point(z,z));
@@ -146,151 +38,343 @@ Scene3D::Scene3D(wxWindow* parent, const wxSize& size) :
     set_bed_shape(p);
 }
 
-float clamp(float low, float x, float high){
-    if(x < low) return low;
-    if(x > high) return high;
-    return x;
+Scene3D::~Scene3D() {
+    if (m_context) {
+        SetCurrent(*m_context);
+        m_vbo_bed.reset();
+        m_vao_bed.reset();
+        m_vbo_grid.reset();
+        m_vao_grid.reset();
+        m_shader.reset();
+        volumes.clear();
+    }
+    delete m_context;
 }
 
-Linef3 Scene3D::mouse_ray(Point win){
-    GLdouble proj[16], mview[16]; 
-    glGetDoublev(GL_MODELVIEW_MATRIX, mview);
-    glGetDoublev(GL_PROJECTION_MATRIX, proj);
-    GLint view[4];
-    glGetIntegerv(GL_VIEWPORT, view);
-    win.y = view[3]-win.y;
-    GLdouble x = 0.0, y = 0.0, z = 0.0;
-    gluUnProject(win.x,win.y,0,mview,proj,view,&x,&y,&z);
-    Pointf3 first = Pointf3(x,y,z);
-    GLint a = gluUnProject(win.x,win.y,1,mview,proj,view,&x,&y,&z);
-    return Linef3(first,Pointf3(x,y,z)); 
+void Scene3D::init_gl(){
+    if(this->init) return;
+    
+    // Initialize GLAD
+    if(!GL::GLManager::init()) {
+        Slic3r::Log::error("Scene3D", "Failed to init GLAD");
+        return;
+    }
+    
+    this->init = true;
+    
+    glEnable(GL_DEPTH_TEST);
+    glDepthFunc(GL_LESS);
+    glEnable(GL_CULL_FACE);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    
+    
+    if (!m_vbo_bed) m_vbo_bed = std::make_unique<GL::VertexBuffer>();
+    if (!m_vao_bed) m_vao_bed = std::make_unique<GL::VertexArray>();
+    if (!m_vbo_grid) m_vbo_grid = std::make_unique<GL::VertexBuffer>();
+    if (!m_vao_grid) m_vao_grid = std::make_unique<GL::VertexArray>();
+
+    init_shaders();
 }
 
-void Scene3D::mouse_move(wxMouseEvent &e){
-    if(e.Dragging()){
-        //const auto s = GetSize();
-        const auto pos = Point(e.GetX(),e.GetY());
-        if(dragging){
-            if (e.ShiftDown()) { // TODO: confirm alt -> shift is ok
-                // Move the camera center on the Z axis based on mouse Y axis movement
-                _camera_target.translate(0, 0, (pos.y - drag_start.y));
-            } else if (e.LeftIsDown()) {
-                // if dragging over blank area with left button, rotate
-                //if (TURNTABLE_MODE) {
-                const float TRACKBALLSIZE = 0.8f, GIMBAL_LOCK_THETA_MAX = 170.0f;
-                                
-                phi += (pos.x - drag_start.x) * TRACKBALLSIZE;
-                theta -= (pos.y - drag_start.y) * TRACKBALLSIZE;
-                theta = clamp(0, theta, GIMBAL_LOCK_THETA_MAX);
-                /*} else {
-                    my $size = $self->GetClientSize;
-                    my @quat = trackball(
-                        $orig->x / ($size->width / 2) - 1,
-                        1 - $orig->y / ($size->height / 2),       #/
-                        $pos->x / ($size->width / 2) - 1,
-                        1 - $pos->y / ($size->height / 2),        #/
-                    );
-                    $self->_quat(mulquats($self->_quat, \@quat));
-                }*/
-            } else if (e.MiddleIsDown() || e.RightIsDown()) {
-                // if dragging over blank area with right button, translate
-                // get point in model space at Z = 0
-                const auto current = mouse_ray(pos).intersect_plane(0);
-                const auto old = mouse_ray(drag_start).intersect_plane(0);
-                _camera_target.translate(current.vector_to(old));
+void Scene3D::init_shaders() {
+    m_shader = std::make_unique<GL::Shader>("MainShader");
+    
+    std::string vs = R"(
+        #version 460 core
+        layout (location = 0) in vec3 aPos;
+        layout (location = 1) in vec3 aNormal;
+        layout (location = 2) in float aTube;
+        
+        uniform mat4 view;
+        uniform mat4 projection;
+        uniform mat4 model;
+        
+        out vec3 v_frag_pos;
+        out vec3 v_normal;
+        out float v_z_height;
+        out float v_tube;
+        
+        void main() {
+            vec4 worldPos = model * vec4(aPos, 1.0);
+            v_frag_pos = vec3(worldPos);
+            v_normal = mat3(transpose(inverse(model))) * aNormal;
+            v_z_height = aPos.z;
+            v_tube = aTube;
+            gl_Position = projection * view * worldPos;
+        }
+    )";
+    
+    std::string fs = R"(
+        #version 460 core
+        out vec4 FragColor;
+        
+        in vec3 v_frag_pos;
+        in vec3 v_normal;
+        in float v_z_height;
+        in float v_tube;
+        
+        uniform vec3 objectColor;
+        uniform vec3 lightPos;
+        uniform vec3 viewPos;
+        uniform float u_clipping_z;
+        
+        void main() {
+            if (v_z_height > u_clipping_z) discard;
+        
+            vec3 N = normalize(v_normal);
+            
+            // 'Stadium' Profile Shading
+            // We assume the extrusion is a rectangle with semicircular ends.
+            // v_tube represents the position across the width (-1 to 1).
+            if (abs(v_tube) > 0.0) {
+                // We calculate a 'perceptual' normal. 
+                // For a stadium shape, the top is flat. The sides are semicircles.
+                // Let's define the 'flat' part as the inner 60% of the extrusion width.
+                float flat_region = 0.6;
+                float side_coord = (abs(v_tube) - flat_region) / (1.0 - flat_region);
+                
+                if (side_coord > 0.0) {
+                    // We are in the curved side region.
+                    // Map side_coord (0..1) to a circular arc normal.
+                    float angle = side_coord * 1.5708; // 0 to 90 degrees (PI/2)
+                    float tilt_z = sin(angle) * sign(v_tube);
+                    float tilt_y = cos(angle); // This would tilt towards top/bottom
+                    
+                    // Tilt the normal based on whether we are looking at the side or top
+                    if (abs(N.z) > 0.5) {
+                         // If we are on the top face, tilt towards the edge
+                         N = normalize(vec3(tilt_z, 0.0, 1.0 - abs(tilt_z)*0.5));
+                    } else {
+                         // If we are already on a side face, refine its curvature
+                         N = normalize(vec3(sign(v_tube), 0.0, -tilt_z * 0.2));
+                    }
+                } else {
+                    // We are in the flat top/bottom region
+                    if (abs(N.z) > 0.5) N = vec3(0, 0, sign(N.z));
+                }
             }
-            //$self->on_viewport_changed->() if $self->on_viewport_changed;
-            Refresh();
+
+            // Lighting (Linear Space)
+            vec3 lightDir = normalize(vec3(0.2, 0.2, 1.0)); 
+            vec3 viewDir = normalize(viewPos - v_frag_pos);
+            
+            // Diffuse
+            float diff = max(dot(N, lightDir), 0.0);
+            
+            // Sharp specular for plastic look
+            vec3 halfwayDir = normalize(lightDir + viewDir);
+            float spec = pow(max(dot(N, halfwayDir), 0.0), 40.0);
+            
+            // Ambient Occlusion for the gap between paths
+            // The gap is deepest at v_tube = 1.0 or -1.0
+            float ao = 1.0 - smoothstep(0.7, 1.0, abs(v_tube)) * 0.4;
+            
+            vec3 ambient = 0.4 * objectColor;
+            vec3 diffuse = diff * objectColor;
+            vec3 specular = vec3(0.3) * spec; // Shiny plastic
+            
+            vec3 result = (ambient + diffuse + specular) * ao;
+            
+            // Subtle darkening at the very bottom of the extrusion to simulate contact
+            result *= (0.8 + 0.2 * smoothstep(-0.1, 0.1, v_z_height));
+
+            result = pow(result, vec3(1.0/2.2));
+            FragColor = vec4(result, 1.0);
         }
-        dragging = true;
-        drag_start = pos; 
-    }else{
-        e.Skip();
+    )";
+    
+    if(!m_shader->init(vs, fs)) {
+        Slic3r::Log::error("Scene3D", "Shader init failed");
     }
 }
 
-void Scene3D::mouse_up(wxMouseEvent &e){
-    dragging = false;
-    Refresh();
-}
+void Scene3D::resize(){
+    const auto s = GetSize();
+    if (s.GetWidth() <= 0 || s.GetHeight() <= 0) return;
 
-void Scene3D::mouse_wheel(wxMouseEvent &e){
-        // Calculate the zoom delta and apply it to the current zoom factor
-        auto _zoom = ((float)e.GetWheelRotation()) / e.GetWheelDelta();
-        /*if ($Slic3r::GUI::Settings->{_}{invert_zoom}) {
-            _zoom *= -1;
-        }*/
-        _zoom = clamp(-4, _zoom,4);
-        _zoom /= 10;
-        zoom /= 1-_zoom;
-        /* 
-        # In order to zoom around the mouse point we need to translate
-        # the camera target
-        my $size = Slic3r::Pointf->new($self->GetSizeWH);
-        my $pos = Slic3r::Pointf->new($e->GetX, $size->y - $e->GetY); #-
-        $self->_camera_target->translate(
-            # ($pos - $size/2) represents the vector from the viewport center
-            # to the mouse point. By multiplying it by $zoom we get the new,
-            # transformed, length of such vector.
-            # Since we want that point to stay fixed, we move our camera target
-            # in the opposite direction by the delta of the length of such vector
-            # ($zoom - 1). We then scale everything by 1/$self->_zoom since 
-            # $self->_camera_target is expressed in terms of model units.
-            -($pos->x - $size->x/2) * ($zoom) / $self->_zoom,
-            -($pos->y - $size->y/2) * ($zoom) / $self->_zoom,
-            0,
-        ) if 0;
-        */
+    if (IsShownOnScreen() && m_context) {
+        SetCurrent(*m_context);
+        init_gl();
+        if (GL::GLManager::is_initialized()) {
+            glViewport(0, 0, s.GetWidth(), s.GetHeight());
+        }
+    }
 
-        dirty = true;
-        Refresh();
+    m_camera.set_viewport(0, 0, s.GetWidth(), s.GetHeight());
+    Refresh();
 }
 
-void Scene3D::mouse_dclick(wxMouseEvent &e){
-    /*
-    if (@{$self->volumes}) {
-        $self->zoom_to_volumes;
-    } else {
-        $self->zoom_to_bed;
-    }*/
+void Scene3D::repaint(wxPaintEvent& e) {
+    if(!IsShownOnScreen()) return;
+    SetCurrent(*m_context);
     
-    dirty = true;
-    Refresh();
+    init_gl();
+    
+    // Update Bed VBOs if needed
+    if(m_bed_dirty) {
+        // Bed (Triangles)
+        std::vector<float> bed_data;
+        for(size_t i=0; i<bed_verts.size(); i+=3) {
+            bed_data.push_back(bed_verts[i]);
+            bed_data.push_back(bed_verts[i+1]);
+            bed_data.push_back(bed_verts[i+2]);
+            // Normal (0,0,1)
+            bed_data.push_back(0.0f);
+            bed_data.push_back(0.0f);
+            bed_data.push_back(1.0f);
+            // Tube (0)
+            bed_data.push_back(0.0f);
+        }
+        m_vbo_bed->upload_data(bed_data.data(), bed_data.size() * sizeof(float));
+        m_vbo_bed->set_count(bed_verts.size() / 3);
+        
+        // Grid (Lines)
+        std::vector<float> grid_data;
+        for(size_t i=0; i<grid_verts.size(); i+=3) {
+            grid_data.push_back(grid_verts[i]);
+            grid_data.push_back(grid_verts[i+1]);
+            grid_data.push_back(grid_verts[i+2]);
+            // Normal (dummy)
+            grid_data.push_back(0.0f);
+            grid_data.push_back(0.0f);
+            grid_data.push_back(1.0f);
+            // Tube (0)
+            grid_data.push_back(0.0f);
+        }
+        m_vbo_grid->upload_data(grid_data.data(), grid_data.size() * sizeof(float));
+        m_vbo_grid->set_count(grid_verts.size() / 3);
+        
+        // Setup VAOs
+        m_vao_bed->bind();
+        m_vbo_bed->bind();
+        m_vao_bed->add_attribute(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)0);
+        m_vao_bed->add_attribute(1, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(3 * sizeof(float)));
+        m_vao_bed->add_attribute(2, 1, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(6 * sizeof(float)));
+        
+        m_vao_grid->bind();
+        m_vbo_grid->bind();
+        m_vao_grid->add_attribute(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)0);
+        m_vao_grid->add_attribute(1, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(3 * sizeof(float)));
+        m_vao_grid->add_attribute(2, 1, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(6 * sizeof(float)));
+        
+        m_bed_dirty = false;
+    }
+    
+    // Clear
+    glClearColor(0.9f, 0.9f, 0.9f, 1.0f); // Default background
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    
+    if(!m_shader) return;
+    
+    m_shader->bind();
+    
+    // Uniforms
+    glm::mat4 view = m_camera.get_view_matrix();
+    glm::mat4 projection = m_camera.get_projection_matrix();
+    glm::vec3 camPos = m_camera.get_position();
+    
+    m_shader->set_uniform("view", view);
+    m_shader->set_uniform("projection", projection);
+    m_shader->set_uniform("viewPos", camPos);
+    m_shader->set_uniform("lightPos", glm::vec3(0.0f, 0.0f, 100.0f)); 
+    m_shader->set_uniform("u_clipping_z", m_clipping_z);
+    
+    draw_ground();
+    draw_axes(Pointf3(0,0,0), 20.0f, 2, true);
+    draw_volumes();
+    
+    glFlush();
+    SwapBuffers();
 }
 
-void Scene3D::resize(){
-    if(!dirty)return;
-    dirty = false;
-    const auto s = GetSize();
-    glViewport(0,0,s.GetWidth(),s.GetHeight());
-    const auto x = s.GetWidth()/zoom,
-               y = s.GetHeight()/zoom,
-               depth = 1000.0f; // my $depth = 10 * max(@{ $self->max_bounding_box->size });
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glOrtho(
-        -x/2, x/2, -y/2, y/2,
-        -depth, 2*depth
-    );
-    glMatrixMode(GL_MODELVIEW);
+void Scene3D::draw_ground() {
+    auto colors = CanvasTheme::GetColors();
+    auto ground = colors.ground_color;
+    auto grid = colors.grid_color;
+    
+    glm::mat4 model = glm::mat4(1.0f);
+    m_shader->set_uniform("model", model);
+    
+    // Bed
+    m_shader->set_uniform("objectColor", glm::vec3(ground.Red()/255.0f, ground.Green()/255.0f, ground.Blue()/255.0f));
+    m_vao_bed->bind();
+    glDrawArrays(GL_TRIANGLES, 0, (GLsizei)m_vbo_bed->get_count());
+    
+    // Grid
+    m_shader->set_uniform("objectColor", glm::vec3(grid.Red()/255.0f, grid.Green()/255.0f, grid.Blue()/255.0f));
+    m_vao_grid->bind();
+    glDrawArrays(GL_LINES, 0, (GLsizei)m_vbo_grid->get_count());
+    m_vao_grid->unbind();
+}
+
+void Scene3D::draw_volumes() {
+    for(auto &volume : volumes) {
+        if(volume.gpu_dirty) {
+            // Create VBO/VAO
+            volume.vbo = std::make_shared<GL::VertexBuffer>();
+            volume.vao = std::make_shared<GL::VertexArray>();
+            
+            // Interleave: Pos(3), Normal(3), Tube(1) = 7 floats per vertex
+            std::vector<float> data;
+            size_t count = volume.model.verts.size() / 3; 
+            for(size_t i=0; i<count; ++i) {
+                // Pos
+                data.push_back(volume.model.verts[i*3]);
+                data.push_back(volume.model.verts[i*3+1]);
+                data.push_back(volume.model.verts[i*3+2]);
+                // Norm
+                if(volume.model.norms.size() > i*3+2) {
+                    data.push_back(volume.model.norms[i*3]);
+                    data.push_back(volume.model.norms[i*3+1]);
+                    data.push_back(volume.model.norms[i*3+2]);
+                } else {
+                    data.push_back(0); data.push_back(0); data.push_back(1);
+                }
+                // Tube Coords
+                if (volume.tube_coords.size() > i) {
+                    data.push_back(volume.tube_coords[i]);
+                } else {
+                    data.push_back(0.0f);
+                }
+            }
+            
+            volume.vbo->upload_data(data.data(), data.size() * sizeof(float));
+            volume.vbo->set_count(count);
+            
+            volume.vao->bind();
+            volume.vbo->bind();
+            volume.vao->add_attribute(0, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), (void*)0);
+            volume.vao->add_attribute(1, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), (void*)(3*sizeof(float)));
+            volume.vao->add_attribute(2, 1, GL_FLOAT, GL_FALSE, 7*sizeof(float), (void*)(6*sizeof(float)));
+            
+            volume.gpu_dirty = false;
+        }
+        
+        glm::mat4 model = glm::mat4(1.0f);
+        model = glm::translate(model, glm::vec3(volume.origin.x, volume.origin.y, volume.origin.z));
+        
+        m_shader->set_uniform("model", model);
+        m_shader->set_uniform("objectColor", glm::vec3(volume.color.Red()/255.0f, volume.color.Green()/255.0f, volume.color.Blue()/255.0f));
+        
+        volume.vao->bind();
+        glDrawArrays(GL_TRIANGLES, 0, (GLsizei)volume.vbo->get_count());
+    }
 }
 
 void Scene3D::set_bed_shape(Points _bed_shape){
-    
     bed_shape = _bed_shape;
     const float GROUND_Z = -0.02f;
     
-    // triangulate bed
     const auto expoly = ExPolygon(Polygon(bed_shape));
     const auto box = expoly.bounding_box();
     bed_bound = box;
     
-    // Update camera target to be the center of the bed
+    // Update camera target
     Point center = bed_bound.center();
-    _camera_target.x = unscale(center.x);
-    _camera_target.y = unscale(center.y);
-    _camera_target.z = 0.0f;
+    m_camera.set_target(glm::vec3(unscale(center.x), unscale(center.y), 0.0f));
 
+    // Triangulate
     {
         std::vector<Polygon> triangles;
         expoly.triangulate(&triangles);
@@ -303,9 +387,9 @@ void Scene3D::set_bed_shape(Points _bed_shape){
             }
         }
     }
+    // Grid
     {
         std::vector<Polyline> lines;
-        Points tmp;
         for (coord_t x = box.min.x; x <= box.max.x; x += scale_(10)) {
             lines.push_back(Polyline());
             lines.back().append(Point(x,box.min.y));
@@ -316,11 +400,9 @@ void Scene3D::set_bed_shape(Points _bed_shape){
             lines.back().append(Point(box.min.x,y));
             lines.back().append(Point(box.max.x,y));
         }
-        // clip with a slightly grown expolygon because our lines lay on the contours and
-        // may get erroneously clipped
-        // my @lines = map Slic3r::Line->new(@$_[0,-1]),
+        
         grid_verts.clear();
-        const Polylines clipped = intersection_pl(lines,offset_ex(expoly,SCALED_EPSILON).at(0));
+        const Polylines clipped = intersection_pl(lines, to_polygons(offset_ex(expoly,SCALED_EPSILON).at(0)));
         for(const Polyline &line : clipped){
             for(const Point &point : line.points){
                 grid_verts.push_back(unscale(point.x));
@@ -328,7 +410,7 @@ void Scene3D::set_bed_shape(Points _bed_shape){
                 grid_verts.push_back(GROUND_Z);
             }
         }
-        // append bed contours
+        // Bed contours
         for(const Line &line : expoly.lines()){
             grid_verts.push_back(unscale(line.a.x));
             grid_verts.push_back(unscale(line.a.y));
@@ -338,592 +420,84 @@ void Scene3D::set_bed_shape(Points _bed_shape){
             grid_verts.push_back(GROUND_Z);
         }
     }
-    
-    //$self->origin(Slic3r::Pointf->new(0,0));
+    m_bed_dirty = true;
+    Refresh();
 }
 
-void Scene3D::init_gl(){
-    if(this->init)return;
-    this->init = true;
-
-    if (const GLubyte* version = glGetString(GL_VERSION)) {
-        Slic3r::Log::info("GUI", std::string("OpenGL Version: ") + (const char*)version);
-    }
-
-    glClearColor(0, 0, 0, 1);
-    glColor3f(1, 0, 0);
-    glEnable(GL_DEPTH_TEST);
-    glClearDepth(1.0);
-    glDepthFunc(GL_LEQUAL);
-    glEnable(GL_CULL_FACE);
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    
-    // Fix normals after scaling
-    glEnable(GL_NORMALIZE);
-
-    // Set antialiasing/multisampling
-    glEnable(GL_LINE_SMOOTH);
-    glEnable(GL_POLYGON_SMOOTH);
-    glEnable(GL_MULTISAMPLE);
-    
-    // ambient lighting - Soft ambient
-    GLfloat ambient[] = {0.3f, 0.3f, 0.3f, 1.0f};
-    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambient);
-    
-    glEnable(GL_LIGHTING);
-    glEnable(GL_LIGHT0);
-    glEnable(GL_LIGHT1);
-    
-    // light from camera - Warmer key light
-    GLfloat pos[] = {1.0f, 0.0f, 1.0f, 0.0f};
-    GLfloat spec[] = {0.6f, 0.6f, 0.6f, 1.0f};
-    GLfloat diff[] = {0.7f, 0.7f, 0.7f, 1.0f};
-    glLightfv(GL_LIGHT1, GL_POSITION, pos);
-    glLightfv(GL_LIGHT1, GL_SPECULAR, spec);
-    glLightfv(GL_LIGHT1, GL_DIFFUSE,  diff);
-    
-    // Enables Smooth Color Shading
-    glShadeModel(GL_SMOOTH);
-    
-    // Material settings - brighter, less plastic
-    GLfloat fbdiff[] = {0.6f, 0.6f, 0.6f, 1.0f};
-    GLfloat fbspec[] = {0.5f, 0.5f, 0.5f, 1.0f};
-    GLfloat fbemis[] = {0.0f, 0.0f, 0.0f, 1.0f};
-    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, fbdiff);
-    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, fbspec);
-    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 60);
-    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, fbemis);
-    
-    // A handy trick -- have surface material mirror the color.
-    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-    glEnable(GL_COLOR_MATERIAL);
-    //glEnable(GL_MULTISAMPLE) if ($self->{can_multisample});
-    
-    load_gl_extensions();
-    if(extensions_loaded) {
-        init_shaders();
+void Scene3D::mouse_move(wxMouseEvent &e){
+    if(e.Dragging()){
+        const auto pos = Point(e.GetX(),e.GetY());
+        if(dragging){
+             if (e.LeftIsDown()) {
+                // Rotate
+                float dx = (pos.x - drag_start.x);
+                float dy = (pos.y - drag_start.y);
+                m_camera.rotate(dy * 0.5f, dx * 0.5f);
+            } else if (e.MiddleIsDown() || e.RightIsDown()) {
+                // Pan
+                float dx = (pos.x - drag_start.x);
+                float dy = (pos.y - drag_start.y);
+                m_camera.pan(dx, dy);
+            }
+            Refresh();
+        }
+        dragging = true;
+        drag_start = pos; 
+    }else{
+        e.Skip();
     }
 }
 
-void Scene3D::init_shaders() {
-    if (m_shader_program != 0) return;
-    
-    const char* vertex_src = R"(
-#version 120
-varying vec3 v_frag_pos;
-varying vec3 v_normal;
-varying vec4 v_color;
-
-void main() {
-    v_frag_pos = vec3(gl_ModelViewMatrix * gl_Vertex);
-    v_normal = gl_NormalMatrix * gl_Normal;
-    v_color = gl_Color;
-    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-}
-)";
-
-    const char* fragment_src = R"(
-#version 120
-varying vec3 v_frag_pos;
-varying vec3 v_normal;
-varying vec4 v_color;
-
-uniform float u_clipping_z;
-uniform vec3 u_light_pos;
-
-void main() {
-    // Clipping (Check Z in world space? No, u_clipping_z is likely world space Z. 
-    // We need world space pos in vertex shader to do this strictly correct, 
-    // but typically simple clipping is done in view space or passed world pos.
-    // Let's assume we can get world Z relatively easily.)
-    // Wait, gl_Vertex in VS is object space. ModelView puts it in View Space.
-    // To clip by "Z height" of the print, we usually mean Object Space Z (since model is usually at 0,0,0).
-    // Let's pass object space Z to FS.
-    // Re-writing Vertex Shader part below implicitly for clarity of thought:
-    // v_obj_pos = gl_Vertex;
-    
-    // NOTE: We need to update the Vertex shader to pass object position.
-}
-)";
-
-    // CORRECTED SHADERS with Tube Profile
-    const char* v_src = R"(
-#version 120
-attribute float a_tube_x;
-varying vec3 v_frag_pos; // View space
-varying vec3 v_normal;   // View space
-varying vec4 v_color;
-varying float v_z_height; // Object space Z
-varying float v_tube_x;
-
-void main() {
-    v_frag_pos = vec3(gl_ModelViewMatrix * gl_Vertex);
-    v_normal = gl_NormalMatrix * gl_Normal;
-    v_color = gl_Color;
-    v_z_height = gl_Vertex.z; // Object space Z is what we clip against
-    v_tube_x = a_tube_x;
-    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+void Scene3D::mouse_up(wxMouseEvent &e){
+    dragging = false;
+    Refresh();
 }
-)";
-
-    const char* f_src = R"(
-#version 120
-// Enable derivatives
-#extension GL_ARB_fragment_shader_derivative : enable
-
-varying vec3 v_frag_pos;
-varying vec3 v_normal;
-varying vec4 v_color;
-varying float v_z_height;
-varying float v_tube_x;
-
-uniform float u_clipping_z;
 
-void main() {
-    if (v_z_height > u_clipping_z) discard;
-
-    vec3 orig_norm = normalize(v_normal);
-    vec3 N = orig_norm;
-    
-    // Auto-calculate Tube Normal using derivatives
-    // We need 'tubeGradient' = direction in view space corresponding to increasing v_tube_x
-    // dFdx return change per pixel X.
-    
-    vec3 dPosdx = dFdx(v_frag_pos);
-    vec3 dPosdy = dFdy(v_frag_pos);
-    
-    // We can't trust normal from cross product of dPos if geometric normal is flat.
-    // But we CAN calculate the gradient of v_tube_x in screen space.
-    float dXdx = dFdx(v_tube_x);
-    float dXdy = dFdy(v_tube_x);
-    
-    // Gradient vector in View Space:
-    // This part is tricky. 
-    // Simplified: We assume surface is flat.
-    // 'tangent' is the direction on the surface where v_tube_x increases.
-    // We can solve this with a system of equations but let's approximate.
-    // gradient = (dPosdx * dXdx + dPosdy * dXdy) / (dXdx^2 + dXdy^2) ... no.
-    
-    // Let's use the cheap trick: Darken edges.
-    // Authentic layers also cast shadows on each other (Ambient Occlusion).
-    // The darkening of edges matches AO.
-    
-    // Improved Normal Mapping:
-    // If v_tube_x is -1..1 across the width.
-    // We want N to tilt.
-    // The tilt direction should be 'across' the tube.
-    // 'across' is perpendicular to 'along'.
-    // If we assume the tube is roughly horizontal (Top View),
-    // We can just guess the cross direction.
-    
-    // Let's fall back to a robust derivative approach if possible.
-    // tube_dir = normalize( dPosdx * dXdx + dPosdy * dXdy ); // This is direction of change
-    
-    float sigma = dXdx*dXdx + dXdy*dXdy;
-    if (sigma > 0.000001) {
-        vec3 T = normalize( dPosdx * dXdx + dPosdy * dXdy ); // Vector pointing towards +1
-        // T is View Space vector of increasing X.
-        // We want N to be Mix(FaceNormal, T).
-        // At v_tube_x = 0, N = FaceNormal.
-        // At v_tube_x = 1, N = T (roughly).
-        
-    // Circular profile:
-        // x = v_tube_x (sin theta)
-        // z = sqrt(1-x^2) (cos theta)
-        // Normal = FaceNormal * z + T * x
-        
-        float x = clamp(v_tube_x, -0.99, 0.99); // Clamp to avoid NaN
-        float z = sqrt(1.0 - x*x);
-        
-    // Anti-aliasing / LOD for Normal Mapping
-        // If the frequency of v_tube_x is too high (zoomed out), fade effect.
-        float delta = fwidth(v_tube_x);
-        float lod_fade = 1.0 - smoothstep(0.8, 1.5, delta);
-        
-        // Blend between Geometric Normal (flat) and Tube Normal based on LOD
-        vec3 tube_normal = normalize(orig_norm * z + T * x);
-        N = normalize(mix(orig_norm, tube_normal, lod_fade));
-    }
-
-    vec3 light_dir = normalize(vec3(0.5, 0.5, 1.0)); // Light from top-right-front
-    
-    // Material Properties - Matte Finish
-    float shininess = 12.0; // Broad, soft highlight
-    float ambientStrength = 0.4; // Reduced to prevent "glow"
-    float specularStrength = 0.1; // Very low specular
-    
-    // Gamma Correction: Convert input color to Linear Space
-    vec3 albedo = pow(v_color.rgb, vec3(2.2));
-    
-    // Ambient
-    vec3 ambient = ambientStrength * vec3(1.0);
-    
-    // Diffuse
-    float diff = max(dot(N, light_dir), 0.0);
-    vec3 diffuse = diff * vec3(1.0);
-    
-    // Specular (Blinn-Phong)
-    vec3 viewDir = normalize(-v_frag_pos);
-    vec3 halfwayDir = normalize(light_dir + viewDir);
-    float spec = pow(max(dot(N, halfwayDir), 0.0), shininess);
-    vec3 specular = specularStrength * spec * vec3(1.0);
-    
-    vec3 lighting = (ambient + diffuse + specular) * albedo;
-    
-    // Edge darkening/AO effect
-    // Stronger strength (0.6) for deep grooves
-    float ao_base = 1.0 - (v_tube_x * v_tube_x) * 0.6; 
-    
-    // Anti-aliasing for AO
-    // Fade AO later to keep layers visible when zoomed out
-    float delta_ao = fwidth(v_tube_x);
-    // Push the fade threshold higher to keep texture at distance
-    float ao_fade = 1.0 - smoothstep(0.8, 1.5, delta_ao);
-    float ao = mix(1.0, ao_base, ao_fade); // mix(no_ao, full_ao, fade_factor)
-    
-    lighting *= ao;
-
-    // Gamma Correction: Back to sRGB
-    lighting = pow(lighting, vec3(1.0/2.2));
-
-    gl_FragColor = vec4(lighting, v_color.a);
-}
-)";
-    
-    GLuint vs = glCreateShader(GL_VERTEX_SHADER);
-    glShaderSource(vs, 1, &v_src, NULL);
-    glCompileShader(vs);
-    
-    GLint success;
-    glGetShaderiv(vs, GL_COMPILE_STATUS, &success);
-    if (!success) {
-        char infoLog[512];
-        glGetShaderInfoLog(vs, 512, NULL, infoLog);
-        Slic3r::Log::error("GUI", std::string("Vertex Shader Compilation Failed: ") + infoLog);
-    }
-    
-    GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
-    glShaderSource(fs, 1, &f_src, NULL);
-    glCompileShader(fs);
-    
-    glGetShaderiv(fs, GL_COMPILE_STATUS, &success);
-    if (!success) {
-        char infoLog[512];
-        glGetShaderInfoLog(fs, 512, NULL, infoLog);
-        Slic3r::Log::error("GUI", std::string("Fragment Shader Compilation Failed: ") + infoLog);
-    }
-    
-    m_shader_program = glCreateProgram();
-    glAttachShader(m_shader_program, vs);
-    glAttachShader(m_shader_program, fs);
-    glLinkProgram(m_shader_program);
-    
-    glGetProgramiv(m_shader_program, GL_LINK_STATUS, &success);
-    if (!success) {
-         char infoLog[512];
-         glGetProgramInfoLog(m_shader_program, 512, NULL, infoLog);
-         Slic3r::Log::error("GUI", std::string("Shader Linking Failed: ") + infoLog);
-    }
-    
-    m_u_clipping_z = glGetUniformLocation(m_shader_program, "u_clipping_z");
-    m_a_tube_x = glGetAttribLocation(m_shader_program, "a_tube_x");
+void Scene3D::mouse_wheel(wxMouseEvent &e){
+    float delta = ((float)e.GetWheelRotation()) / e.GetWheelDelta();
+    // delta is typically 1 or -1
+    // We want a multiplier
+    float zoom_factor = (delta > 0) ? 1.1f : 0.9f;
+    m_camera.zoom(zoom_factor);
+    Refresh();
 }
 
-
-void Scene3D::draw_background(){
-    glDisable(GL_LIGHTING);
-    glPushMatrix();
-    glLoadIdentity();
-    
-    glMatrixMode(GL_PROJECTION);
-    glPushMatrix();
-    glLoadIdentity();
-    
-    glBegin(GL_QUADS);
-    auto colors = CanvasTheme::GetColors();
-    auto bottom = colors.canvas_bg_bottom, top = colors.canvas_bg_top;
-    if(colors.solid_background){
-         bottom = top = colors.canvas_bg_top;
-    }
-    glColor3ub(bottom.Red(), bottom.Green(), bottom.Blue());
-    glVertex2f(-1.0,-1.0);
-    glVertex2f(1,-1.0);
-    glColor3ub(top.Red(), top.Green(), top.Blue());
-    glVertex2f(1, 1);
-    glVertex2f(-1.0, 1);
-    glEnd();
-    glPopMatrix();
-    
-    glMatrixMode(GL_MODELVIEW);
-    glPopMatrix();
+void Scene3D::mouse_dclick(wxMouseEvent &e){
+    // Reset view?
+    Refresh();
 }
 
-void Scene3D::draw_ground(){
-    glDisable(GL_DEPTH_TEST);
-    
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    
-    glEnableClientState(GL_VERTEX_ARRAY);
-    /*my $triangle_vertex;
-    if (HAS_VBO) {
-        ($triangle_vertex) =
-            glGenBuffersARB_p(1);
-        $self->bed_triangles->bind($triangle_vertex);
-        glBufferDataARB_p(GL_ARRAY_BUFFER_ARB, $self->bed_triangles, GL_STATIC_DRAW_ARB);
-        glVertexPointer_c(3, GL_FLOAT, 0, 0);
-    } else {*/
-    // fall back on old behavior
-    glVertexPointer(3, GL_FLOAT, 0, bed_verts.data());
-    auto colors = CanvasTheme::GetColors();
-    const auto ground = colors.ground_color, grid = colors.grid_color;
-        
-    glColor4ub(ground.Red(), ground.Green(), ground.Blue(),ground.Alpha());
-    glNormal3d(0,0,1);
-    glDrawArrays(GL_TRIANGLES, 0, bed_verts.size() / 3);
-    
-    // we need depth test for grid, otherwise it would disappear when looking
-    // the object from below
-    glEnable(GL_DEPTH_TEST);
-
-    // draw grid
-    glLineWidth(2);
-    /*my $grid_vertex;
-    if (HAS_VBO) {
-        ($grid_vertex) =
-            glGenBuffersARB_p(1);
-        $self->bed_grid_lines->bind($grid_vertex);
-        glBufferDataARB_p(GL_ARRAY_BUFFER_ARB, $self->bed_grid_lines, GL_STATIC_DRAW_ARB);
-        glVertexPointer_c(3, GL_FLOAT, 0, 0);
-    } else {*/
-    // fall back on old behavior
-    glVertexPointer(3, GL_FLOAT, 0, grid_verts.data());
-    
-    glColor4ub(grid.Red(), grid.Green(), grid.Blue(),grid.Alpha());
-    glNormal3d(0,0,1);
-    glDrawArrays(GL_LINES, 0, grid_verts.size() / 3);
-    glDisableClientState(GL_VERTEX_ARRAY);
-    
-    glDisable(GL_BLEND);
-    /*if (HAS_VBO) { 
-        # Turn off buffer objects to let the rest of the draw code work.
-        glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
-        glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
-        glDeleteBuffersARB_p($grid_vertex);
-        glDeleteBuffersARB_p($triangle_vertex);
-    }*/
+Linef3 Scene3D::mouse_ray(Point win){
+    glm::vec3 orig, dir;
+    m_camera.screen_to_world(win.x, win.y, orig, dir);
+    // Return a Linef3 (segment) that is long enough
+    return Linef3(Pointf3(orig.x, orig.y, orig.z), Pointf3(orig.x + dir.x*1000.0f, orig.y + dir.y*1000.0f, orig.z + dir.z*1000.0f));
 }
 
-void Scene3D::draw_axes (Pointf3 center, float length, int width, bool always_visible){
-    /*
-    my $volumes_bb = $self->volumes_bounding_box;
-    
-    {
-        # draw axes
-        # disable depth testing so that axes are not covered by ground
-        glDisable(GL_DEPTH_TEST);
-        my $origin = $self->origin;
-        my $axis_len = max(
-            max(@{ $self->bed_bounding_box->size }),
-            1.2 * max(@{ $volumes_bb->size }),
-        );
-        glLineWidth(2);
-        glBegin(GL_LINES);
-        # draw line for x axis
-        glColor3f(1, 0, 0);
-        glVertex3f(@$origin, $ground_z);
-        glVertex3f($origin->x + $axis_len, $origin->y, $ground_z);  #,,
-        # draw line for y axis
-        glColor3f(0, 1, 0);
-        glVertex3f(@$origin, $ground_z);
-        glVertex3f($origin->x, $origin->y + $axis_len, $ground_z);  #++
-        glEnd();
-        # draw line for Z axis
-        # (re-enable depth test so that axis is correctly shown when objects are behind it)
-        glEnable(GL_DEPTH_TEST);
-        glBegin(GL_LINES);
-        glColor3f(0, 0, 1);
-        glVertex3f(@$origin, $ground_z);
-        glVertex3f(@$origin, $ground_z+$axis_len);
-        glEnd();
-    }
-   */ 
-    if (always_visible) {
-        glDisable(GL_DEPTH_TEST);
-    } else {
-        glEnable(GL_DEPTH_TEST);
-    }
-    glLineWidth(width);
-    glBegin(GL_LINES);
-    // draw line for x axis
-    glColor3f(1, 0, 0);
-    glVertex3f(center.x, center.y, center.z);
-    glVertex3f(center.x + length, center.y, center.z);
-    // draw line for y axis
-    glColor3f(0, 1, 0);
-    glVertex3f(center.x, center.y, center.z);
-    glVertex3f(center.x, center.y + length, center.z);
-    glEnd();
-
-    // draw line for Z axis
-    // (re-enable depth test so that axis is correctly shown when objects are behind it)
-    glEnable(GL_DEPTH_TEST);
-    glBegin(GL_LINES);
-    glColor3f(0, 0, 1);
-    glVertex3f(center.x, center.y, center.z);
-    glVertex3f(center.x, center.y, center.z + length);
-    glEnd();
+// Draw axes fallback
+void Scene3D::draw_axes(Pointf3 center, float length, int width, bool always_visible) {
+    // TODO: Implement Axes with VBOs
 }
-void Scene3D::draw_volumes(){
-    if (extensions_loaded && m_shader_program != 0) {
-        glUseProgram(m_shader_program);
-        if (m_u_clipping_z != -1) {
-            glUniform1f(m_u_clipping_z, m_clipping_z);
-        }
-    } else {
-        // Fallback for no shader support? Or just rely on fixed function
-    }
-
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    
-    glEnableClientState(GL_VERTEX_ARRAY);
-    glEnableClientState(GL_NORMAL_ARRAY);
-    if (m_a_tube_x != -1) glEnableVertexAttribArray(m_a_tube_x);
-    
-    for(const Volume &volume : volumes){
-        glPushMatrix();
-        glTranslatef(volume.origin.x, volume.origin.y, volume.origin.z);
-        glCullFace(GL_BACK);
-        glVertexPointer(3, GL_FLOAT, 0, volume.model.verts.data());
-        glNormalPointer(GL_FLOAT, 0, volume.model.norms.data());
-        if (m_a_tube_x != -1 && !volume.tube_coords.empty()) {
-            glVertexAttribPointer(m_a_tube_x, 1, GL_FLOAT, GL_FALSE, 0, volume.tube_coords.data());
-        } else if (m_a_tube_x != -1) {
-             // Disable or set default?
-             glVertexAttrib1f(m_a_tube_x, 0.0f);
-        }
-        glColor4ub(volume.color.Red(), volume.color.Green(), volume.color.Blue(), 255);
-        glDrawArrays(GL_TRIANGLES, 0, volume.model.verts.size()/3);
 
-        if (volume.selected) {
-            glDisable(GL_LIGHTING);
-            glLineWidth(2.0f);
-            glColor3f(1.0f, 1.0f, 1.0f);
-            
-            const Pointf3& min = volume.bb.min;
-            const Pointf3& max = volume.bb.max;
-            
-            // Calculate corner line length (min of 10.0f or 20% of dimension)
-            float lx = std::min(10.0f, (float)((max.x - min.x) * 0.2));
-            float ly = std::min(10.0f, (float)((max.y - min.y) * 0.2));
-            float lz = std::min(10.0f, (float)((max.z - min.z) * 0.2));
+void Scene3D::draw_background() {}
 
-            glBegin(GL_LINES);
-            for (float x : {min.x, max.x}) {
-                for (float y : {min.y, max.y}) {
-                    for (float z : {min.z, max.z}) {
-                        float dx = (x == min.x) ? lx : -lx;
-                        float dy = (y == min.y) ? ly : -ly;
-                        float dz = (z == min.z) ? lz : -lz;
-                        
-                        // Line along X
-                        glVertex3f(x, y, z); glVertex3f(x + dx, y, z);
-                        // Line along Y
-                        glVertex3f(x, y, z); glVertex3f(x, y + dy, z);
-                        // Line along Z
-                        glVertex3f(x, y, z); glVertex3f(x, y, z + dz);
-                    }
-                }
-            }
-            glEnd();
-            glEnable(GL_LIGHTING);
-        }
-
-        glPopMatrix();
-    }
-    
-    if (m_a_tube_x != -1) glDisableVertexAttribArray(m_a_tube_x);
-    glDisableClientState(GL_NORMAL_ARRAY);
-    glDisableClientState(GL_VERTEX_ARRAY);
-    glDisable(GL_BLEND);
-    
-    if (extensions_loaded && m_shader_program != 0) {
-        glUseProgram(0);
-    }
+// Stub for load_object
+Volume Scene3D::load_object(ModelVolume &mv, ModelInstance &mi) {
+    Volume vol;
+    vol.origin = Pointf3(mi.offset.x, mi.offset.y, 0.0f);
+    // Load mesh logic would go here
+    return vol;
 }
 
 void Scene3D::set_camera_view(Direction dir) {
-    switch(dir) {
-        case Direction::Top:      theta = 0.0f;   phi = 0.0f;   break;
-        case Direction::Bottom:   theta = 180.0f; phi = 0.0f;   break;
-        case Direction::Front:    theta = 90.0f;  phi = 0.0f;   break;
-        case Direction::Back:     theta = 90.0f;  phi = 180.0f; break;
-        case Direction::Left:     theta = 90.0f;  phi = -90.0f; break;
-        case Direction::Right:    theta = 90.0f;  phi = 90.0f;  break;
-        case Direction::Diagonal: theta = 45.0f;  phi = 45.0f;  break;
-    }
-    dirty = true;
+    // TODO: Map direction to camera angles
     Refresh();
 }
 
-void Scene3D::repaint(wxPaintEvent& e) {
-    if(!this->IsShownOnScreen())return;
-    // There should be a context->IsOk check once wx is updated
-    if(!this->SetCurrent(*(this->glContext)))return;
-    init_gl();
-    resize();
-
-    glClearColor(1, 1, 1, 1);
-    glClearDepth(1);
-    glDepthFunc(GL_LESS);
-    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-    
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
-    
-    glRotatef(-theta, 1, 0, 0); // pitch
-    glRotatef(phi, 0, 0, 1);   // yaw
-    /*} else {
-        my @rotmat = quat_to_rotmatrix($self->quat);
-        glMultMatrixd_p(@rotmat[0..15]);
-    }*/
-    glTranslatef(-_camera_target.x, -_camera_target.y, -_camera_target.z);
-     
-    // light from above
-    GLfloat pos[] = {-0.5f, -0.5f, 1.0f, 0.0f}, spec[] = {0.2f, 0.2f, 0.2f, 1.0f}, diff[] = {0.5f, 0.5f, 0.5f, 1.0f};    
-    glLightfv(GL_LIGHT0, GL_POSITION, pos);
-    glLightfv(GL_LIGHT0, GL_SPECULAR, spec);
-    glLightfv(GL_LIGHT0, GL_DIFFUSE,  diff);
-
-    before_render();
-
-    draw_background();
-    draw_ground();
-        /*my $origin = $self->origin;
-        my $axis_len = max(
-            max(@{ $self->bed_bounding_box->size }),
-            1.2 * max(@{ $volumes_bb->size }),
-        );*/
-    draw_axes(Pointf3(0.0f,0.0f,0.0f), 20.0f, 2, true);
-    
-    // draw objects
-    glEnable(GL_LIGHTING);
-    draw_volumes();
-    
-    after_render();
-    
-    if (dragging/*defined $self->_drag_start_pos || defined $self->_drag_start_xy*/) {
-        draw_axes(_camera_target, 10.0f, 1, true/*camera,10,1,true*/);
-        draw_axes(_camera_target, 10.0f, 4, false/*camera,10,4,false*/);
-    }
-
-    glFlush();
-    SwapBuffers();
-    // Calling glFinish has a performance penalty, but it seems to fix some OpenGL driver hang-up with extremely large scenes.
-    glFinish();
-
+void Scene3D::set_z_clipping(float z) {
+    m_clipping_z = z;
+    Refresh();
 }
 
-} } // Namespace Slic3r::GUI
+
+} } // Namespace Slic3r::GUI
\ No newline at end of file
diff --git a/src/GUI/Scene3D.hpp b/src/GUI/Scene3D.hpp
index f809377e..79743b7e 100644
--- a/src/GUI/Scene3D.hpp
+++ b/src/GUI/Scene3D.hpp
@@ -1,5 +1,7 @@
 #ifndef SCENE3D_HPP
 #define SCENE3D_HPP
+
+#include "GL/GLManager.hpp"
 #include <wx/wxprec.h>
 #ifndef WX_PRECOMP
     #include <wx/wx.h>
@@ -12,6 +14,12 @@
 #include "BoundingBox.hpp"
 #include "Model.hpp"
 
+// Modern GL
+#include "GL/Shader.hpp"
+#include "GL/Camera.hpp"
+#include "GL/Buffer.hpp"
+#include <memory>
+
 namespace Slic3r { namespace GUI {
 
 enum class Direction { Top, Bottom, Left, Right, Front, Back, Diagonal };
@@ -19,75 +27,79 @@ enum class Direction { Top, Bottom, Left, Right, Front, Back, Diagonal };
 struct Volume {
     wxColor color;
     Pointf3 origin;
-    GLVertexArray model;
+    GLVertexArray model; // CPU Data
     BoundingBoxf3 bb;
     std::vector<float> tube_coords;
     bool selected = false;
+
+    // GPU Data
+    std::shared_ptr<GL::VertexBuffer> vbo;
+    std::shared_ptr<GL::VertexArray> vao;
+    bool gpu_dirty = true;
 };
 
 class Scene3D : public wxGLCanvas {
 public:
     Scene3D(wxWindow* parent, const wxSize& size);
+    ~Scene3D();
     
     void set_camera_view(Direction dir);
+    void set_z_clipping(float z);
 
 private:
-    wxGLContext* glContext;
+    wxGLContext* m_context = nullptr;
     
-    // Camera settings
-    float zoom = 3.0f, phi = 45.0f, theta = 45.0f;
-    Pointf3 _camera_target = Pointf3(0.0f,0.0f,0.0f);
+    // GL State
+    bool init = false;
+    void init_gl();
+    void init_shaders();
     
-    // Optional point used for dragging calculations
+    // Camera
+    GL::Camera m_camera;
     bool dragging = false;
     Point drag_start = Point(0,0);
     
-    // Bed Stuff
-    std::vector<float> bed_verts, grid_verts;
+    // Rendering Resources
+    std::unique_ptr<GL::Shader> m_shader;
+    
+    // Bed Geometry
     Points bed_shape;
     BoundingBox bed_bound;
+    std::unique_ptr<GL::VertexBuffer> m_vbo_bed;
+    std::unique_ptr<GL::VertexArray> m_vao_bed;
+    std::unique_ptr<GL::VertexBuffer> m_vbo_grid;
+    std::unique_ptr<GL::VertexArray> m_vao_grid;
+    bool m_bed_dirty = true;
+    std::vector<float> bed_verts;
+    std::vector<float> grid_verts;
     
-    void repaint(wxPaintEvent &e); // Redraws every frame
-    
-    bool dirty = true;             // Resize needs to be called before render
-    void resize();                 // Handle glViewport and projection matrices
-    
-    bool init = false;             // Has opengl been initted
-    void init_gl();                // Handles lights and materials
-    void init_shaders();           // Compiles and links the shaders
-    
-    // Shader data
-    unsigned int m_shader_program = 0;
-    int m_u_clipping_z = -1;
-    int m_u_light_pos = -1;
-    int m_u_view_pos = -1;
-    int m_a_tube_x = -1;
     float m_clipping_z = 10000.0f;
     
-    // Used in repaint
+    // Internal Rendering Methods
+    void repaint(wxPaintEvent &e); 
+    void resize();                 
     void draw_background();
     void draw_ground();
     void draw_axes(Pointf3 center, float length, int width, bool alwaysvisible);
     
-public:
-    void set_z_clipping(float z) { m_clipping_z = z; Refresh(); }
-    
 protected:
-    Linef3 mouse_ray(Point win); // Utility for backtracking from window coordinates
-    void draw_volumes();         // Draws volumes (for use in before_render)
+    Linef3 mouse_ray(Point win);
+    void draw_volumes();
     void set_bed_shape(Points _bed_shape);
     
     std::vector<Volume> volumes;
     Volume load_object(ModelVolume &mv, ModelInstance &mi);
     
-    // Virtual methods to override
+    // Event Handlers
     virtual void mouse_up(wxMouseEvent &e);
     virtual void mouse_move(wxMouseEvent &e);
     virtual void mouse_dclick(wxMouseEvent &e);
     virtual void mouse_wheel(wxMouseEvent &e);
+    
+    // Hooks
     virtual void before_render(){};
     virtual void after_render(){};
  };
 
 } } // Namespace Slic3r::GUI
-#endif
+#endif
\ No newline at end of file
diff --git a/src/GUI/Settings.cpp b/src/GUI/Settings.cpp
index 1f214a81..0474bdc7 100644
--- a/src/GUI/Settings.cpp
+++ b/src/GUI/Settings.cpp
@@ -3,6 +3,7 @@
 #include "misc_ui.hpp"
 #include <wx/fileconf.h> 
 #include <wx/display.h>
+#include <wx/tokenzr.h>
 
 namespace Slic3r { namespace GUI {
 
@@ -37,6 +38,14 @@ void Settings::save_settings() {
     config.Write("reload_behavior", (long)this->reload);
     config.Write("rotation_controls", wxString(this->rotation_controls));
 
+    // Save Quick Settings
+    wxString qs_str = "";
+    for (size_t i = 0; i < this->quick_settings.size(); ++i) {
+        qs_str << this->quick_settings[i];
+        if (i < this->quick_settings.size() - 1) qs_str << ",";
+    }
+    config.Write("quick_settings", qs_str);
+
     // Save window positions
     for (auto const& [name, tuple] : window_pos) {
         config.Write(name + "_pos_x", std::get<0>(tuple).x);
@@ -93,6 +102,16 @@ void Settings::load_settings() {
     };
 
     load_win("main_frame");
+
+    // Load Quick Settings
+    wxString qs_str;
+    if (config.Read("quick_settings", &qs_str)) {
+        this->quick_settings.clear();
+        wxStringTokenizer tokenizer(qs_str, ",");
+        while (tokenizer.HasMoreTokens()) {
+            this->quick_settings.push_back(tokenizer.GetNextToken().ToStdString());
+        }
+    }
 }
 
 void Settings::save_window_pos(wxWindow* ref, wxString name) {
diff --git a/src/GUI/Settings.hpp b/src/GUI/Settings.hpp
index 802eb444..135935aa 100644
--- a/src/GUI/Settings.hpp
+++ b/src/GUI/Settings.hpp
@@ -1,6 +1,5 @@
 #ifndef SETTINGS_HPP
 #define SETTINGS_HPP
-
 #include <wx/wxprec.h>
 #ifndef WX_PRECOMP
     #include <wx/wx.h>
@@ -10,6 +9,7 @@
 #include <tuple>
 #include <vector>
 #include <array>
+#include <algorithm>
 
 #include "libslic3r.h"
 #include "Theme/ThemeManager.hpp"
@@ -66,6 +66,18 @@ class Settings {
 
         std::array<std::vector<wxString>, preset_types> default_presets {};
 
+        // Quick Settings (Pinned)
+        std::vector<std::string> quick_settings {};
+        bool is_quick_setting(const std::string& key) const {
+             return std::find(quick_settings.begin(), quick_settings.end(), key) != quick_settings.end();
+        }
+        void toggle_quick_setting(const std::string& key) {
+             auto it = std::find(quick_settings.begin(), quick_settings.end(), key);
+             if (it == quick_settings.end()) quick_settings.push_back(key);
+             else quick_settings.erase(it);
+             save_settings();
+        }
+
         /// Storage for window positions
         std::map<wxString, std::tuple<wxPoint, wxSize, bool> > window_pos { std::map<wxString, std::tuple<wxPoint, wxSize, bool> >() };
 
diff --git a/src/GUI/Widgets/ThemedControls.cpp b/src/GUI/Widgets/ThemedControls.cpp
index 40bffa5e..0ab01205 100644
--- a/src/GUI/Widgets/ThemedControls.cpp
+++ b/src/GUI/Widgets/ThemedControls.cpp
@@ -249,6 +249,13 @@ void ThemedSelect::Append(const wxString& item, const wxBitmapBundle& icon) {
     Refresh();
 }
 
+void ThemedSelect::SetItemIcon(int n, const wxBitmapBundle& icon) {
+    if (n >= 0 && n < (int)m_icons.size()) {
+        m_icons[n] = icon;
+        Refresh();
+    }
+}
+
 wxString ThemedSelect::GetString(int n) const {
     if (n >= 0 && n < (int)m_options.size()) return m_options[n];
     return "";
diff --git a/src/GUI/Widgets/ThemedControls.hpp b/src/GUI/Widgets/ThemedControls.hpp
index ffef407e..d06ed2ff 100644
--- a/src/GUI/Widgets/ThemedControls.hpp
+++ b/src/GUI/Widgets/ThemedControls.hpp
@@ -60,6 +60,7 @@ public:
     // Compatibility helpers
     void Clear();
     void Append(const wxString& item, const wxBitmapBundle& icon = wxBitmapBundle());
+    void SetItemIcon(int n, const wxBitmapBundle& icon);
     size_t GetCount() const { return m_options.size(); }
     int FindString(const wxString& s) const;
     void SetString(int n, const wxString& s);
diff --git a/src/GUI/Widgets/ThemedMenuBar.cpp b/src/GUI/Widgets/ThemedMenuBar.cpp
index 6086e9c8..d571e579 100644
--- a/src/GUI/Widgets/ThemedMenuBar.cpp
+++ b/src/GUI/Widgets/ThemedMenuBar.cpp
@@ -130,6 +130,8 @@ void ThemedMenuBar::OnLeftUp(wxMouseEvent& event)
 
 void ThemedMenuBar::OnMotion(wxMouseEvent& event)
 {
+    if (m_isResetting) return;
+
     wxPoint pos = event.GetPosition();
     int prevIndex = m_hoveredIndex;
     m_hoveredIndex = -1;
@@ -171,11 +173,23 @@ void ThemedMenuBar::OpenMenu(int index)
     ThemedMenuPopup* popup = new ThemedMenuPopup(this, entry.menu);
     
     popup->SetOnDismissCallback([this]() {
+        m_isResetting = true;
         m_openMenuIndex = -1;
-        m_hoveredIndex = -1; // Ensure stale hover doesn't keep it highlighted
+        m_hoveredIndex = -1; 
         m_currentPopup = nullptr;
+        
         Refresh();
         Update(); 
+
+        // Also force parent update if possible, to ensure the repaint is visible before any modal dialogs
+        if (GetParent()) {
+            GetParent()->Update();
+        }
+
+        // Defer clearing the resetting flag to allow event queue to settle
+        wxTheApp->CallAfter([this]() {
+            m_isResetting = false;
+        });
     });
 
     wxPoint screenPos = ClientToScreen(wxPoint(entry.rect.GetLeft(), entry.rect.GetBottom()));
diff --git a/src/GUI/Widgets/ThemedMenuBar.hpp b/src/GUI/Widgets/ThemedMenuBar.hpp
index ccd49d1b..5e308b7d 100644
--- a/src/GUI/Widgets/ThemedMenuBar.hpp
+++ b/src/GUI/Widgets/ThemedMenuBar.hpp
@@ -38,6 +38,7 @@ private:
     std::vector<MenuEntry> m_menus;
     int m_hoveredIndex = -1;
     int m_openMenuIndex = -1;
+    bool m_isResetting = false;
     
     // Non-modal tracking
     class ThemedMenuPopup* m_currentPopup = nullptr; 
diff --git a/src/GUI/Widgets/ThemedMenuPopup.cpp b/src/GUI/Widgets/ThemedMenuPopup.cpp
index 676f5497..4ebde5ca 100644
--- a/src/GUI/Widgets/ThemedMenuPopup.cpp
+++ b/src/GUI/Widgets/ThemedMenuPopup.cpp
@@ -20,8 +20,8 @@ void ThemedMenuPopup::OnEraseBackground(wxEraseEvent& event)
     // Do nothing to prevent flicker
 }
 
-ThemedMenuPopup::ThemedMenuPopup(wxWindow* parent, ThemedMenu* menu)
-    : wxPopupTransientWindow(parent, wxBORDER_NONE), m_menu(menu)
+ThemedMenuPopup::ThemedMenuPopup(wxWindow* parent, ThemedMenu* menu, ThemedMenuPopup* parentPopup)
+    : wxPopupTransientWindow(parent, wxBORDER_NONE), m_menu(menu), m_parentPopup(parentPopup)
 {
     SetBackgroundStyle(wxBG_STYLE_PAINT);
     m_font = ThemeManager::GetFont(ThemeManager::FontSize::Small);
@@ -300,7 +300,7 @@ void ThemedMenuPopup::ExecuteItem(const ItemInfo& item)
 {
     if (item.hasSubMenu) {
         // Recursively show submenu
-        ThemedMenuPopup* sub = new ThemedMenuPopup(this, item.subMenu.get());
+        ThemedMenuPopup* sub = new ThemedMenuPopup(this, item.subMenu.get(), this);
         
         // Pass callbacks down to submenus so actions inside them also trigger the reset
         sub->SetOnDismissCallback(m_onDismiss);
@@ -312,7 +312,22 @@ void ThemedMenuPopup::ExecuteItem(const ItemInfo& item)
     }
 
     int cmdId = item.id;
-    Dismiss(); 
+    
+    // Explicitly call the dismiss callback early to clear Bar highlight
+    // before any modal dialog might block the UI.
+    if (m_onDismiss) {
+        m_onDismiss();
+    }
+
+    // Dismiss the entire chain of popups
+    ThemedMenuPopup* current = this;
+    while (current) {
+        ThemedMenuPopup* parent = current->m_parentPopup;
+        // Prevent redundant callback triggers during this explicit teardown
+        current->m_onDismiss = nullptr; 
+        current->Dismiss(); 
+        current = parent;
+    }
     
     // Direct Execution! No event loop detour.
     // Defer to next event loop iteration to allow the menu to close and repaint first
diff --git a/src/GUI/Widgets/ThemedMenuPopup.hpp b/src/GUI/Widgets/ThemedMenuPopup.hpp
index b046fb0c..fa6325b2 100644
--- a/src/GUI/Widgets/ThemedMenuPopup.hpp
+++ b/src/GUI/Widgets/ThemedMenuPopup.hpp
@@ -12,7 +12,7 @@ namespace GUI {
 
 class ThemedMenuPopup : public wxPopupTransientWindow {
 public:
-    ThemedMenuPopup(wxWindow* parent, ThemedMenu* menu);
+    ThemedMenuPopup(wxWindow* parent, ThemedMenu* menu, ThemedMenuPopup* parentPopup = nullptr);
     virtual ~ThemedMenuPopup();
 
     // Override to dismiss properly
@@ -35,6 +35,7 @@ protected:
 
 private:
     ThemedMenu* m_menu; 
+    ThemedMenuPopup* m_parentPopup = nullptr;
     bool m_ownsMenu = false;
     int m_hoveredIndex = -1;
     
diff --git a/vcpkg.json b/vcpkg.json
index b80ab411..186e4111 100644
--- a/vcpkg.json
+++ b/vcpkg.json
@@ -16,7 +16,9 @@
     "boost-bind",
     "boost-date-time",
     "boost-foreach",
-    "wxwidgets"
+    "wxwidgets",
+    "glad",
+    "glm"
   ],
   "builtin-baseline": "6d7bf7ef2193e2d1c5798a5ff8811d533104c861"
 }
